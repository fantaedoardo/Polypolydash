<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Tap Dash — Polpo in Fuga</title>
  <style>
    html, body { margin:0; padding:0; height:100%; overflow:hidden; background:#021024; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    canvas { width:100vw; height:100vh; display:block; touch-action: manipulation; }
    .hint {
      position: fixed; left: 12px; right: 12px; bottom: 10px;
      color: rgba(255,255,255,0.78); font-size: 12px; line-height: 1.25;
      text-shadow: 0 2px 12px rgba(0,0,0,0.55);
      user-select:none; pointer-events:none;
    }
  </style>
</head>
<body>
<canvas id="c"></canvas>
<div class="hint">Tap per saltare • 1 km = 100 punti • +1 vita ogni 3 km • 10 km = SUPER traguardo</div>

<script>
(() => {
  "use strict";

  // ---------- Canvas ----------
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha: false });

  function resize() {
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    canvas.width  = Math.floor(innerWidth  * dpr);
    canvas.height = Math.floor(innerHeight * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  addEventListener("resize", resize, { passive:true });
  resize();

  // ---------- Helpers ----------
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const rand = (a,b)=>a + Math.random()*(b-a);
  const lerp = (a,b,t)=>a+(b-a)*t;

  // ---------- Tunings ----------
  const GROUND_RATIO = 0.80;

  const GRAVITY = 2350;
  const JUMP_V  = -840;

  const KM_PX = 1500;
  const POINTS_PER_KM = 100;

  const SPEED_START = 250;
  const SPEED_SOFT_MAX = 560;
  const SPEED_HARD_MAX = 860;

  const SPAWN_START = 1.20;
  const SPAWN_MIN   = 0.38;
  const GAP_START   = 360;
  const GAP_MIN     = 165;

  const START_LIVES = 2;
  const LIFE_EVERY_KM = 3;
  const HIT_INVINCIBLE = 1.05;

  const SHARK_INTRO_TIME = 2.2;

  // ---------- State ----------
  const state = {
    started:false,
    over:false,
    t:0,
    dt:0,
    lastTs:0,

    speed:SPEED_START,
    spawnTimer:0,
    distancePx:0,
    kmCount:0,
    score:0,
    best:Number(localStorage.getItem("octoTapBest")||0),

    lives:START_LIVES,
    inv:0,

    cameraBob:0,
    shake:0,

    addedUpToKm: -1,
  };

  // ---------- Entities ----------
  const octo = {
    x:0, y:0, w:56, h:48,
    vy:0,
    onGround:true,

    jumpPhase:0,
    blink:0,
    wobble:0
  };

  const obstacles = [];
  const swimmers = [];
  const bubbles = [];

  const layers = [
    { x:0, speed:0.15, amp:12, alpha:0.30 },
    { x:0, speed:0.28, amp:18, alpha:0.22 },
    { x:0, speed:0.42, amp:22, alpha:0.16 }
  ];

  function layout() {
    const W = innerWidth, H = innerHeight;
    const groundY = H * GROUND_RATIO;
    octo.x = Math.max(80, W * 0.18);
    octo.y = groundY - octo.h;
  }

  function reset() {
    state.started=false;
    state.over=false;
    state.t=0;
    state.dt=0;
    state.lastTs=0;

    state.speed=SPEED_START;
    state.spawnTimer=0;
    state.distancePx=0;
    state.kmCount=0;
    state.score=0;

    state.lives=START_LIVES;
    state.inv=0;
    state.cameraBob=0;
    state.shake=0;

    state.addedUpToKm=-1;

    obstacles.length=0;
    swimmers.length=0;
    bubbles.length=0;

    octo.vy=0;
    octo.onGround=true;
    octo.jumpPhase=0;
    octo.blink=0;
    octo.wobble=0;

    for (let i=0;i<8;i++) spawnFish(true);

    layout();
  }

  // ---------- Input ----------
  function jump() {
    if (state.over) return;
    if (!state.started) state.started=true;

    if (octo.onGround) {
      octo.vy = JUMP_V;
      octo.onGround=false;
      for (let i=0;i<7;i++) spawnBubble(octo.x+octo.w*0.2, octo.y+octo.h*0.6, rand(2,5));
    }
  }

  function restartTap(x,y){
    if (!state.over) return false;
    const W=innerWidth, H=innerHeight;
    const bw=Math.min(270, W*0.64), bh=54;
    const bx=(W-bw)/2, by=H*0.62;
    return x>=bx && x<=bx+bw && y>=by && y<=by+bh;
  }

  function onPointer(ev){
    const rect = canvas.getBoundingClientRect();
    const x = (ev.clientX ?? ev.touches?.[0]?.clientX) - rect.left;
    const y = (ev.clientY ?? ev.touches?.[0]?.clientY) - rect.top;

    if (restartTap(x,y)) { reset(); return; }
    jump();
  }
  canvas.addEventListener("pointerdown", onPointer, { passive:true });
  addEventListener("keydown", (e)=>{
    if (e.code==="Space" || e.code==="ArrowUp") {
      e.preventDefault();
      if (state.over) { reset(); return; }
      jump();
    }
  });

  let lastTouch=0;
  addEventListener("touchend",(e)=>{
    const now=Date.now();
    if (now-lastTouch<=350) e.preventDefault();
    lastTouch=now;
  },{passive:false});

  // ---------- Difficulty ----------
  function km() { return state.distancePx / KM_PX; }

  function difficulty(kmVal) {
    const a = clamp(kmVal/6, 0, 1);
    const b = clamp((kmVal-6)/4, 0, 1);
    const c = clamp((kmVal-10)/5, 0, 1);
    return a*0.9 + b*1.4 + c*2.4;
  }

  function computeSpeed(kmVal) {
    const d = difficulty(kmVal);
    const soft = lerp(SPEED_START, SPEED_SOFT_MAX, clamp(d/1.8, 0, 1));
    const hard = lerp(SPEED_SOFT_MAX, SPEED_HARD_MAX, clamp((d-1.8)/2.9, 0, 1));
    return d < 1.8 ? soft : hard;
  }

  function computeSpawnInterval(kmVal) {
    const d = difficulty(kmVal);
    const t = clamp(d/4.7, 0, 1);
    return clamp(SPAWN_START * (1 - 0.72*Math.pow(t, 1.25)), SPAWN_MIN, SPAWN_START);
  }

  function computeMinGap(kmVal) {
    const d = difficulty(kmVal);
    const t = clamp(d/4.7, 0, 1);
    return clamp(GAP_START * (1 - 0.55*Math.pow(t, 1.15)), GAP_MIN, GAP_START);
  }

  // ---------- Spawning: corals ----------
  function spawnCoral() {
    const W=innerWidth, H=innerHeight;
    const groundY=H*GROUND_RATIO;
    const kmVal = km();
    const d = difficulty(kmVal);

    const baseH = rand(54, 92) + d*6;
    const h = clamp(baseH, 56, 170);
    const w = clamp(h * rand(0.35, 0.55), 26, 86);

    const kind = (d > 2.2 && Math.random()<0.25) ? "fan" : (Math.random()<0.5 ? "branch" : "tube");

    obstacles.push({
      x: W + rand(40, 140),
      y: groundY - h,
      w, h,
      kind,
      swaySeed: Math.random()*10
    });
  }

  function spawnFish(initial=false) {
    const W=innerWidth, H=innerHeight;
    const groundY=H*GROUND_RATIO;
    const y = rand(H*0.18, groundY-120);
    swimmers.push({
      x: initial ? rand(0,W) : W + rand(40, 220),
      y,
      s: rand(0.6, 1.2),
      kind: "fish",
      phase: Math.random()*10,
      speedK: rand(0.12, 0.28)
    });
  }

  function spawnDiver() {
    const W=innerWidth, H=innerHeight;
    swimmers.push({
      x: W + rand(60, 200),
      y: rand(H*0.22, H*0.55),
      s: rand(0.85, 1.05),
      kind: "diver",
      phase: Math.random()*10,
      speedK: rand(0.10, 0.18)
    });
  }

  function spawnGoggles() {
    const W=innerWidth, H=innerHeight;
    swimmers.push({
      x: W + rand(60, 220),
      y: rand(H*0.26, H*0.62),
      s: rand(0.9, 1.15),
      kind: "goggles",
      phase: Math.random()*10,
      speedK: rand(0.16, 0.24)
    });
  }

  function spawnSpecialFish() {
    const W=innerWidth, H=innerHeight;
    swimmers.push({
      x: W + rand(80, 240),
      y: rand(H*0.20, H*0.60),
      s: rand(1.0, 1.5),
      kind: "special",
      phase: Math.random()*10,
      speedK: rand(0.18, 0.30)
    });
  }

  function spawnBubble(x,y,r) {
    bubbles.push({
      x: x + rand(-6,6),
      y: y + rand(-6,6),
      r,
      vx: rand(-12, 12),
      vy: rand(-70, -120),
      life: 0,
      maxLife: rand(0.9, 1.6)
    });
  }

  function applyKmDecor(kmInt) {
    const mod = kmInt % 3;
    if (mod === 0) spawnDiver();
    if (mod === 1) spawnGoggles();
    if (mod === 2) spawnSpecialFish();
    for (let i=0;i<2;i++) spawnFish(false);
  }

  // ---------- Collision ----------
  function aabb(ax,ay,aw,ah,bx,by,bw,bh){
    return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
  }

  function takeHit() {
    if (state.inv > 0) return;
    state.lives -= 1;
    state.inv = HIT_INVINCIBLE;
    state.shake = 10;
    for (let i=0;i<14;i++) spawnBubble(octo.x+octo.w*0.4, octo.y+octo.h*0.5, rand(2,6));
    if (state.lives <= 0) {
      state.over = true;
      if (state.score > state.best) {
        state.best = state.score;
        localStorage.setItem("octoTapBest", String(state.best));
      }
    }
  }

  // ---------- Drawing ----------
  function drawBackground(W,H,groundY) {
    const g = ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0, "#2ff3ff");
    g.addColorStop(0.35, "#1b9dff");
    g.addColorStop(1, "#021024");
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);

    ctx.globalAlpha = 0.12;
    ctx.fillStyle = "#ffffff";
    const t = state.t;
    for (let i=0;i<6;i++){
      const yy = H*(0.12 + i*0.09) + Math.sin(t*0.9 + i)*10;
      ctx.beginPath();
      ctx.ellipse(W/2 + Math.sin(t*0.4+i)*70, yy, W*0.58, 30+Math.sin(t*1.1+i)*8, 0, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;

    layers.forEach((L, idx) => {
      L.x -= state.speed * L.speed * state.dt;
      if (L.x < -W) L.x += W;

      ctx.globalAlpha = L.alpha;
      ctx.fillStyle = idx===0 ? "#0b3a5e" : idx===1 ? "#072d4d" : "#05223d";
      for (let rep=-1; rep<=1; rep++) {
        const ox = L.x + rep*W;
        ctx.beginPath();
        ctx.moveTo(ox, groundY);
        for (let x=0; x<=W; x+=44) {
          const yy = groundY - (80 + idx*42) + Math.sin((x*0.012) + t*0.6 + idx)*L.amp;
          ctx.lineTo(ox + x, yy);
        }
        ctx.lineTo(ox + W, groundY);
        ctx.closePath();
        ctx.fill();
      }
      ctx.globalAlpha = 1;
    });

    const sand = ctx.createLinearGradient(0, groundY, 0, H);
    sand.addColorStop(0, "#ffdc9e");
    sand.addColorStop(1, "#cfa56b");
    ctx.fillStyle = sand;
    ctx.fillRect(0, groundY, W, H-groundY);

    ctx.strokeStyle = "rgba(255,255,255,0.22)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(0, groundY+2);
    ctx.lineTo(W, groundY+2);
    ctx.stroke();
  }

  function drawCoral(o) {
    const sway = Math.sin(state.t*1.6 + o.swaySeed) * 3;
    const x=o.x, y=o.y, w=o.w, h=o.h;

    ctx.fillStyle = "rgba(0,0,0,0.12)";
    ctx.beginPath();
    ctx.ellipse(x+w/2, y+h+8, w*0.55, 10, 0, 0, Math.PI*2);
    ctx.fill();

    if (o.kind === "tube") {
      ctx.fillStyle = "rgba(255,110,180,0.95)";
      for (let i=0;i<3;i++){
        const tw = w*(0.28 + i*0.06);
        const th = h*(0.72 + i*0.08);
        const tx = x + w*0.10 + i*w*0.22 + sway*0.15;
        const ty = y + h - th;
        ctx.beginPath();
        ctx.roundRect(tx, ty, tw, th, 14);
        ctx.fill();
        ctx.fillStyle = "rgba(255,220,245,0.45)";
        ctx.beginPath();
        ctx.roundRect(tx+tw*0.18, ty+th*0.10, tw*0.22, th*0.75, 10);
        ctx.fill();
        ctx.fillStyle = "rgba(255,110,180,0.95)";
      }
    } else if (o.kind === "fan") {
      ctx.fillStyle = "rgba(255,120,60,0.95)";
      ctx.beginPath();
      ctx.moveTo(x+w*0.15 + sway, y+h);
      ctx.quadraticCurveTo(x+w*0.25 + sway, y+h*0.35, x+w*0.5 + sway*0.2, y+h*0.18);
      ctx.quadraticCurveTo(x+w*0.82 + sway, y+h*0.35, x+w*0.85 + sway, y+h);
      ctx.closePath();
      ctx.fill();

      ctx.strokeStyle = "rgba(255,230,200,0.45)";
      ctx.lineWidth = 2;
      for (let i=0;i<6;i++){
        ctx.beginPath();
        ctx.moveTo(x+w*(0.20+i*0.12)+sway*0.6, y+h);
        ctx.quadraticCurveTo(x+w*(0.30+i*0.08)+sway*0.4, y+h*0.52, x+w*(0.45+i*0.04)+sway*0.2, y+h*0.22);
        ctx.stroke();
      }
    } else {
      ctx.fillStyle = "rgba(140,255,120,0.92)";
      ctx.beginPath();
      ctx.roundRect(x+w*0.42 + sway*0.3, y+h*0.32, w*0.16, h*0.68, 10);
      ctx.fill();

      const branches = 4;
      for (let i=0;i<branches;i++){
        const bx = x+w*0.50 + sway*0.3;
        const by = y+h*(0.45 + i*0.12);
        const len = w*(0.38 + i*0.06);
        ctx.strokeStyle = "rgba(140,255,120,0.92)";
        ctx.lineWidth = 8;
        ctx.lineCap = "round";
        ctx.beginPath();
        ctx.moveTo(bx, by);
        ctx.lineTo(bx + len*(i%2?1:-1) + sway, by - h*0.10);
        ctx.stroke();

        ctx.fillStyle = "rgba(255,255,255,0.22)";
        ctx.beginPath();
        ctx.arc(bx + len*(i%2?1:-1) + sway, by - h*0.10, 5, 0, Math.PI*2);
        ctx.fill();
      }
    }
  }

  function drawSwimmer(s) {
    const t = state.t;
    const bob = Math.sin(t*1.2 + s.phase) * 6;
    const x = s.x, y = s.y + bob;
    const scale = s.s;

    ctx.save();
    ctx.translate(x, y);
    ctx.scale(scale, scale);

    if (s.kind === "fish") {
      ctx.fillStyle = "rgba(255,240,90,0.95)";
      ctx.beginPath();
      ctx.ellipse(0,0,18,10,0,0,Math.PI*2);
      ctx.fill();
      ctx.fillStyle = "rgba(255,120,50,0.95)";
      ctx.beginPath();
      ctx.moveTo(-16,0);
      ctx.lineTo(-30,-10);
      ctx.lineTo(-30,10);
      ctx.closePath();
      ctx.fill();
      ctx.fillStyle = "#0a1c2d";
      ctx.beginPath();
      ctx.arc(8,-2,2.3,0,Math.PI*2);
      ctx.fill();
    }

    if (s.kind === "special") {
      ctx.fillStyle = "rgba(180,120,255,0.95)";
      ctx.beginPath();
      ctx.ellipse(0,0,20,16,0,0,Math.PI*2);
      ctx.fill();
      ctx.strokeStyle = "rgba(255,255,255,0.45)";
      ctx.lineWidth = 2;
      for (let i=0;i<8;i++){
        const a = i*(Math.PI*2/8);
        ctx.beginPath();
        ctx.moveTo(Math.cos(a)*8, Math.sin(a)*6);
        ctx.lineTo(Math.cos(a)*26, Math.sin(a)*20);
        ctx.stroke();
      }
      ctx.fillStyle = "#081629";
      ctx.beginPath();
      ctx.arc(6,-2,2.6,0,Math.PI*2);
      ctx.fill();
    }

    if (s.kind === "diver") {
      ctx.fillStyle = "rgba(30,30,40,0.9)";
      ctx.beginPath();
      ctx.roundRect(-10,-14,20,28,10);
      ctx.fill();
      ctx.fillStyle = "rgba(255,220,180,0.95)";
      ctx.beginPath();
      ctx.arc(0,-18,10,0,Math.PI*2);
      ctx.fill();
      ctx.fillStyle = "rgba(80,220,255,0.85)";
      ctx.beginPath();
      ctx.roundRect(-10,-24,20,12,6);
      ctx.fill();
      ctx.strokeStyle = "rgba(255,255,255,0.35)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(-4,-12); ctx.lineTo(-14,2);
      ctx.moveTo(4,-12);  ctx.lineTo(14,2);
      ctx.stroke();
      ctx.globalAlpha = 0.7;
      ctx.fillStyle = "rgba(255,255,255,0.85)";
      ctx.beginPath(); ctx.arc(16,-20,3,0,Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(22,-28,2,0,Math.PI*2); ctx.fill();
      ctx.globalAlpha = 1;
    }

    if (s.kind === "goggles") {
      ctx.fillStyle = "rgba(255,120,0,0.92)";
      ctx.beginPath();
      ctx.roundRect(-22,-10,44,20,10);
      ctx.fill();
      ctx.fillStyle = "rgba(120,240,255,0.85)";
      ctx.beginPath();
      ctx.ellipse(-10,0,10,7,0,0,Math.PI*2);
      ctx.ellipse(10,0,10,7,0,0,Math.PI*2);
      ctx.fill();
      ctx.strokeStyle = "rgba(255,255,255,0.4)";
      ctx.lineWidth = 2;
      ctx.beginPath(); ctx.moveTo(-34,0); ctx.lineTo(-22,0);
      ctx.moveTo(22,0); ctx.lineTo(34,0);
      ctx.stroke();
    }

    ctx.restore();
  }

  function drawOctopus(W,H,groundY) {
    const t = state.t;
    const vy = octo.vy;
    const stretch = clamp((-vy)/1100, -0.35, 0.45);
    const squash = clamp((vy)/1200, 0, 0.35);
    const sx = 1 + squash - stretch*0.25;
    const sy = 1 - squash + stretch;

    const bob = Math.sin(t*2.4 + octo.wobble) * 2.5;
    const invFlash = (state.inv>0) ? (Math.sin(t*24)>0 ? 0.35 : 1.0) : 1.0;

    ctx.globalAlpha = 0.18 * invFlash;
    ctx.fillStyle = "#000";
    ctx.beginPath();
    const shW = octo.w*0.62 * (octo.onGround ? 1 : 0.75);
    ctx.ellipse(octo.x+octo.w/2, groundY+8, shW, 12, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;

    ctx.save();
    ctx.translate(octo.x + octo.w/2, octo.y + octo.h/2 + bob);
    ctx.scale(sx, sy);

    const hue = 180 + Math.sin(t*0.6)*18;
    const bodyColor = `hsl(${hue}, 85%, 62%)`;
    const bellyColor = `hsla(${hue+25}, 90%, 78%, 0.8)`;

    ctx.globalAlpha = invFlash;

    ctx.fillStyle = bodyColor;
    ctx.beginPath();
    ctx.ellipse(0, -2, octo.w*0.42, octo.h*0.36, 0, 0, Math.PI*2);
    ctx.fill();

    ctx.beginPath();
    ctx.ellipse(0, -18, octo.w*0.34, octo.h*0.30, 0, 0, Math.PI*2);
    ctx.fill();

    ctx.fillStyle = bellyColor;
    ctx.beginPath();
    ctx.ellipse(6, 0, octo.w*0.18, octo.h*0.16, 0, 0, Math.PI*2);
    ctx.fill();

    const tentN = 6;
    for (let i=0;i<tentN;i++){
      const a = -Math.PI*0.9 + i*(Math.PI*1.8/(tentN-1));
      const sway = Math.sin(t*5 + i*1.2 + octo.jumpPhase) * (octo.onGround? 6 : 12);
      const len = octo.h*(0.40 + (i%2)*0.06);
      const x0 = Math.cos(a)*octo.w*0.16;
      const y0 = octo.h*0.16;
      const x1 = x0 + Math.cos(a)*len*0.35 + sway*0.35;
      const y1 = y0 + len*0.55;
      const x2 = x0 + Math.cos(a)*len*0.15 + sway;
      const y2 = y0 + len*0.92;

      ctx.strokeStyle = `hsla(${hue}, 85%, 58%, 0.95)`;
      ctx.lineWidth = 10 - i*0.7;
      ctx.lineCap = "round";
      ctx.beginPath();
      ctx.moveTo(x0, y0);
      ctx.quadraticCurveTo(x1, y1, x2, y2);
      ctx.stroke();

      ctx.fillStyle = "rgba(255,255,255,0.25)";
      for (let k=0;k<3;k++){
        const tt = (k+1)/4;
        const px = (1-tt)*(1-tt)*x0 + 2*(1-tt)*tt*x1 + tt*tt*x2;
        const py = (1-tt)*(1-tt)*y0 + 2*(1-tt)*tt*y1 + tt*tt*y2;
        ctx.beginPath();
        ctx.arc(px+2, py, 2.2, 0, Math.PI*2);
        ctx.fill();
      }
    }

    octo.blink -= state.dt;
    if (octo.blink<=0 && Math.random()<0.012) octo.blink = 0.11;

    ctx.fillStyle = "#062033";
    if (octo.blink>0) {
      ctx.strokeStyle = "#062033";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(-14,-18); ctx.lineTo(-6,-18);
      ctx.moveTo(6,-18);  ctx.lineTo(14,-18);
      ctx.stroke();
    } else {
      ctx.beginPath();
      ctx.arc(-10,-18,3.4,0,Math.PI*2);
      ctx.arc(10,-18,3.4,0,Math.PI*2);
      ctx.fill();
      ctx.fillStyle = "rgba(255,255,255,0.75)";
      ctx.beginPath();
      ctx.arc(-9,-19,1.2,0,Math.PI*2);
      ctx.arc(11,-19,1.2,0,Math.PI*2);
      ctx.fill();
    }

    ctx.strokeStyle = "rgba(6,32,51,0.9)";
    ctx.lineWidth = 3;
    ctx.lineCap="round";
    ctx.beginPath();
    ctx.arc(0,-8,9,0.15*Math.PI,0.85*Math.PI);
    ctx.stroke();

    ctx.globalAlpha = 1;
    ctx.restore();
  }

  function drawBubbles() {
    ctx.globalAlpha = 0.7;
    ctx.fillStyle = "rgba(255,255,255,0.85)";
    for (const b of bubbles) {
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 0.20;
      ctx.beginPath();
      ctx.arc(b.x - b.r*0.3, b.y - b.r*0.3, b.r*0.35, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 0.7;
    }
    ctx.globalAlpha = 1;
  }

  function drawHUD(W,H) {
    const pad=14;

    ctx.fillStyle="rgba(0,0,0,0.26)";
    ctx.beginPath();
    ctx.roundRect(pad,pad,240,78,14);
    ctx.fill();

    ctx.fillStyle="rgba(255,255,255,0.94)";
    ctx.font="800 18px system-ui, -apple-system, Segoe UI, Roboto";
    ctx.fillText(`Punti: ${state.score}`, pad+14, pad+28);

    const kmVal = km();
    ctx.fillStyle="rgba(255,255,255,0.82)";
    ctx.font="650 14px system-ui, -apple-system, Segoe UI, Roboto";
    ctx.fillText(`Distanza: ${kmVal.toFixed(2)} km`, pad+14, pad+50);

    ctx.fillText(`Vite: ${"❤".repeat(Math.max(0, Math.min(8, state.lives)))}${state.lives>8 ? " +" : ""}`, pad+14, pad+70);

    ctx.textAlign="right";
    ctx.fillStyle="rgba(255,255,255,0.88)";
    ctx.font="700 14px system-ui, -apple-system, Segoe UI, Roboto";
    ctx.fillText(`Best: ${state.best}`, W-pad, pad+22);
    ctx.textAlign="left";

    if (!state.started && !state.over) {
      ctx.fillStyle="rgba(255,255,255,0.95)";
      ctx.font="900 30px system-ui, -apple-system, Segoe UI, Roboto";
      ctx.fillText("POLPO IN FUGA", pad, H*0.20);
      ctx.fillStyle="rgba(255,255,255,0.84)";
      ctx.font="650 16px system-ui, -apple-system, Segoe UI, Roboto";
      ctx.fillText("Tap per entrare in gioco • Tap per saltare", pad, H*0.20+34);
    }

    if (state.over) {
      ctx.textAlign="center";
      ctx.fillStyle="rgba(0,0,0,0.45)";
      ctx.fillRect(0,0,W,H);

      ctx.fillStyle="rgba(255,255,255,0.95)";
      ctx.font="950 34px system-ui, -apple-system, Segoe UI, Roboto";
      ctx.fillText("GAME OVER", W/2, H*0.34);

      ctx.fillStyle="rgba(255,255,255,0.90)";
      ctx.font="750 18px system-ui, -apple-system, Segoe UI, Roboto";
      ctx.fillText(`Punti: ${state.score} • Best: ${state.best}`, W/2, H*0.34+34);

      const bw=Math.min(270, W*0.64), bh=54;
      const bx=(W-bw)/2, by=H*0.62;
      ctx.fillStyle="rgba(80,255,210,0.95)";
      ctx.beginPath(); ctx.roundRect(bx,by,bw,bh,16); ctx.fill();

      ctx.fillStyle="rgba(2,16,36,0.95)";
      ctx.font="950 18px system-ui, -apple-system, Segoe UI, Roboto";
      ctx.fillText("RESTART", W/2, by+34);
      ctx.textAlign="left";
    }
  }

  function drawSharkIntro(W,H) {
    if (!state.started) return;
    const t = state.t;
    const elapsed = Math.min(SHARK_INTRO_TIME, t);
    if (elapsed >= SHARK_INTRO_TIME) return;

    const a = 1 - (elapsed / SHARK_INTRO_TIME);
    ctx.globalAlpha = 0.55 * a;

    const sx = octo.x - 140 + Math.sin(t*3)*12;
    const sy = octo.y + 10 + Math.sin(t*4)*6;

    ctx.save();
    ctx.translate(sx, sy);
    ctx.scale(1.05, 1.05);

    ctx.fillStyle = "rgba(0,0,0,0.55)";
    ctx.beginPath();
    ctx.ellipse(0, 0, 58, 22, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(-55,0);
    ctx.lineTo(-90,-18);
    ctx.lineTo(-90,18);
    ctx.closePath();
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(-5,-22);
    ctx.lineTo(10,-52);
    ctx.lineTo(22,-20);
    ctx.closePath();
    ctx.fill();

    ctx.restore();
    ctx.globalAlpha = 1;
  }

  if (!CanvasRenderingContext2D.prototype.roundRect) {
    CanvasRenderingContext2D.prototype.roundRect = function(x,y,w,h,r){
      r=Math.min(r,w/2,h/2);
      this.beginPath();
      this.moveTo(x+r,y);
      this.arcTo(x+w,y,x+w,y+h,r);
      this.arcTo(x+w,y+h,x,y+h,r);
      this.arcTo(x,y+h,x,y,r);
      this.arcTo(x,y,x+w,y,r);
      this.closePath();
      return this;
    };
  }

  function step(ts) {
    if (!state.lastTs) state.lastTs = ts;
    state.dt = Math.min(0.033, (ts - state.lastTs)/1000);
    state.lastTs = ts;
    state.t += state.dt;

    const W=innerWidth, H=innerHeight;
    const groundY=H*GROUND_RATIO;

    state.cameraBob = Math.sin(state.t*1.2) * 3.5;

    if (state.inv>0) state.inv = Math.max(0, state.inv - state.dt);

    const kmVal = km();
    const targetSpeed = computeSpeed(kmVal);
    state.speed += (targetSpeed - state.speed) * (1 - Math.pow(0.001, state.dt));

    const spawnInterval = computeSpawnInterval(kmVal);
    const minGap = computeMinGap(kmVal);

    if (state.started && !state.over) {
      state.distancePx += state.speed * state.dt;

      const kmNow = Math.floor(state.distancePx / KM_PX);
      if (kmNow > state.kmCount) {
        const delta = kmNow - state.kmCount;
        state.kmCount = kmNow;
        state.score += delta * POINTS_PER_KM;

        for (let k=state.addedUpToKm+1; k<=kmNow; k++) {
          applyKmDecor(k);
          state.addedUpToKm = k;
        }

        if (kmNow > 0 && kmNow % LIFE_EVERY_KM === 0) {
          state.lives += 1;
          for (let i=0;i<12;i++) spawnBubble(octo.x+octo.w*0.6, octo.y+octo.h*0.2, rand(2,6));
        }
      }

      state.spawnTimer -= state.dt;
      const last = obstacles[obstacles.length-1];
      const okGap = !last || (W + 80) - last.x >= minGap;

      if (state.spawnTimer <= 0 && okGap) {
        spawnCoral();
        state.spawnTimer = spawnInterval + rand(-0.12, 0.18);
      }

      octo.vy += GRAVITY * state.dt;
      octo.y += octo.vy * state.dt;

      octo.jumpPhase += state.dt * (octo.onGround ? 1.6 : 6.0);
      octo.wobble += state.dt * 0.6;

      if (octo.y >= groundY - octo.h) {
        octo.y = groundY - octo.h;
        octo.vy = 0;
        octo.onGround = true;
      } else {
        octo.onGround = false;
      }

      for (let i=obstacles.length-1; i>=0; i--) {
        obstacles[i].x -= state.speed * state.dt;
        if (obstacles[i].x + obstacles[i].w < -40) obstacles.splice(i,1);
      }

      for (let i=swimmers.length-1; i>=0; i--) {
        const s = swimmers[i];
        s.x -= state.speed * s.speedK * state.dt;
        if (s.x < -240) swimmers.splice(i,1);
      }
      if (swimmers.filter(s=>s.kind==="fish").length < 10) spawnFish(false);

      if (Math.random() < 0.10) spawnBubble(rand(0,W), H*GROUND_RATIO + rand(-80,-20), rand(1.5,3.5));
      for (let i=bubbles.length-1; i>=0; i--) {
        const b = bubbles[i];
        b.life += state.dt;
        b.x += b.vx * state.dt;
        b.y += b.vy * state.dt;
        b.vx += Math.sin(state.t*2 + i)*3 * state.dt;
        if (b.life > b.maxLife || b.y < -20) bubbles.splice(i,1);
      }

      const bx = octo.x + 12;
      const by = octo.y + 8;
      const bw = octo.w - 22;
      const bh = octo.h - 14;

      for (const o of obstacles) {
        const ox = o.x + 6;
        const oy = o.y + 4;
        const ow = o.w - 12;
        const oh = o.h - 6;
        if (aabb(bx,by,bw,bh, ox,oy,ow,oh)) {
          takeHit();
          break;
        }
      }
    } else {
      octo.y = groundY - octo.h;
      octo.vy = 0;
      octo.onGround = true;
    }

    let shakeX=0, shakeY=0;
    if (state.shake>0) {
      state.shake -= state.dt * 22;
      const s = Math.max(0, state.shake);
      shakeX = (Math.random()*2-1)*s;
      shakeY = (Math.random()*2-1)*s;
    }

    ctx.save();
    ctx.translate(shakeX, shakeY + state.cameraBob);

    drawBackground(W,H,groundY);

    for (const s of swimmers) drawSwimmer(s);
    for (const o of obstacles) drawCoral(o);
    drawOctopus(W,H,groundY);
    drawSharkIntro(W,H);
    drawBubbles();
    drawHUD(W,H);

    ctx.restore();

    requestAnimationFrame(step);
  }

  reset();
  requestAnimationFrame(step);

})();
</script>
</body>
</html>
