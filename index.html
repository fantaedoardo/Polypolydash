<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover" />
  <meta name="theme-color" content="#021024" />
  <title>Tap Dash — Polpo in Fuga (Flappy Coral)</title>
  <style>
    html, body { margin:0; padding:0; height:100%; overflow:hidden; background:#021024; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    canvas { width:100vw; height:100vh; display:block; touch-action: none; }
    .hint{
      position: fixed; left: 12px; right: 12px; bottom: 10px;
      color: rgba(255,255,255,0.78); font-size: 12px; line-height: 1.25;
      text-shadow: 0 2px 12px rgba(0,0,0,0.55);
      user-select:none; pointer-events:none;
    }
  </style>
</head>
<body>
<canvas id="c"></canvas>
<div class="hint">Tap/press = sali • tieni premuto = salita più lunga • 1 km = 100 punti • +1 vita ogni 3 km • 10 km = traguardo</div>

<script>
(() => {
  "use strict";

  // ---------- Canvas ----------
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha:false });

  function resize() {
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    canvas.width  = Math.floor(innerWidth  * dpr);
    canvas.height = Math.floor(innerHeight * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  addEventListener("resize", resize, { passive:true });
  resize();

  // ---------- Helpers ----------
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const rand=(a,b)=>a+Math.random()*(b-a);
  const lerp=(a,b,t)=>a+(b-a)*t;
  const smoothStep=t=>t*t*(3-2*t);

  // ---------- Core rules ----------
  // "km" in horizontal distance (shorter so 10km is a real goal)
  const KM_PX = 1100;
  const POINTS_PER_KM = 100;

  const START_LIVES = 2;
  const LIFE_EVERY_KM = 3;
  const HIT_INVINCIBLE = 1.05;

  // Flappy-like vertical physics (EASIER than previous)
  const GRAVITY = 1350;           // down accel
  const HOLD_THRUST = 2450;       // up accel while holding
  const TAP_IMPULSE = -250;       // immediate small kick on tap
  const HOLD_MAX_TIME = 0.22;     // holding gives extra lift, capped
  const VY_UP_CAP = -520;
  const VY_DOWN_CAP = 760;

  // Horizontal speed pacing: easy early, harder near 10km but doable
  const SPEED_START = 240;
  const SPEED_5KM   = 320;
  const SPEED_9KM   = 400;
  const SPEED_10KM  = 430;

  // Obstacles: corals top+bottom, with a gap
  // Gap is based on screen height to stay fair on mobile.
  function gapStart(H){ return Math.max(210, Math.min(320, H*0.34)); }
  function gapEnd(H){   return Math.max(170, Math.min(260, H*0.27)); } // last km tighter but not insane

  const SPAWN_START = 1.45;
  const SPAWN_5KM   = 1.25;
  const SPAWN_9KM   = 1.05;
  const SPAWN_10KM  = 0.98;

  // Safe warmup: no obstacles for first seconds after start
  const SAFE_START_TIME = 1.35;

  // ---------- State ----------
  const state = {
    started:false,
    over:false,
    t:0, dt:0, lastTs:0,

    speed:SPEED_START,
    spawnTimer:0,
    distancePx:0,
    kmCount:0,
    score:0,
    best:Number(localStorage.getItem("octoFlapBest2")||0),

    lives:START_LIVES,
    inv:0,

    holding:false,
    holdTime:0,

    shake:0,

    addedUpToKm:-1
  };

  // ---------- Entities ----------
  const octo = {
    x:0, y:0, r:22,
    vy:0,
    blink:0,
    phase:0
  };

  // obstacle: {x, gapY, gapH, w, seed, hue}
  const obstacles = [];
  const swimmers = [];
  const bubbles = [];

  const layers = [
    { x:0, speed:0.14, amp:12, alpha:0.32 },
    { x:0, speed:0.28, amp:18, alpha:0.24 },
    { x:0, speed:0.42, amp:22, alpha:0.18 }
  ];

  function W(){ return innerWidth; }
  function H(){ return innerHeight; }

  function reset() {
    state.started=false;
    state.over=false;
    state.t=0; state.dt=0; state.lastTs=0;

    state.speed=SPEED_START;
    state.spawnTimer=0.7; // slight delay even after start
    state.distancePx=0;
    state.kmCount=0;
    state.score=0;

    state.lives=START_LIVES;
    state.inv=0;
    state.holding=false;
    state.holdTime=0;
    state.shake=0;
    state.addedUpToKm=-1;

    obstacles.length=0;
    swimmers.length=0;
    bubbles.length=0;

    octo.x = Math.max(90, W()*0.24);
    octo.y = H()*0.52;
    octo.vy = 0;
    octo.blink = 0;
    octo.phase = 0;

    for (let i=0;i<10;i++) spawnFish(true);
  }

  // ---------- Input ----------
  function startIfNeeded(){ if (!state.started && !state.over) state.started = true; }

  function down() {
    if (state.over) return;
    startIfNeeded();
    state.holding = true;
    state.holdTime = 0;

    // small impulse so tap always helps
    octo.vy = Math.min(octo.vy, 120);
    octo.vy += TAP_IMPULSE;

    for (let i=0;i<5;i++) spawnBubble(octo.x-10, octo.y+8, rand(2,4));
  }
  function up() {
    state.holding = false;
    state.holdTime = 0;
  }

  function restartTap(x,y){
    if (!state.over) return false;
    const bw=Math.min(270, W()*0.64), bh=54;
    const bx=(W()-bw)/2, by=H()*0.62;
    return x>=bx && x<=bx+bw && y>=by && y<=by+bh;
  }

  function getXY(ev){
    const rect = canvas.getBoundingClientRect();
    const p = (ev.touches && ev.touches[0]) ? ev.touches[0] : ev;
    return { x:(p.clientX ?? 0) - rect.left, y:(p.clientY ?? 0) - rect.top };
  }

  canvas.addEventListener("pointerdown", (ev)=>{
    const {x,y}=getXY(ev);
    if (restartTap(x,y)) { reset(); return; }
    down();
  }, { passive:true });
  canvas.addEventListener("pointerup", up, { passive:true });
  canvas.addEventListener("pointercancel", up, { passive:true });
  canvas.addEventListener("touchstart", (e)=>{ e.preventDefault(); }, { passive:false });

  addEventListener("keydown", (e)=>{
    if (e.code==="Space" || e.code==="ArrowUp") { e.preventDefault(); if (state.over){ reset(); return; } down(); }
  });
  addEventListener("keyup", (e)=>{
    if (e.code==="Space" || e.code==="ArrowUp") { e.preventDefault(); up(); }
  });

  // ---------- Difficulty ----------
  function km(){ return state.distancePx / KM_PX; }

  function speedAt(kmVal){
    if (kmVal <= 5){
      const t = smoothStep(clamp(kmVal/5,0,1));
      return lerp(SPEED_START, SPEED_5KM, t);
    }
    if (kmVal <= 9){
      const t = smoothStep(clamp((kmVal-5)/4,0,1));
      return lerp(SPEED_5KM, SPEED_9KM, t);
    }
    const t = smoothStep(clamp((kmVal-9)/1,0,1));
    return lerp(SPEED_9KM, SPEED_10KM, t);
  }

  function spawnIntervalAt(kmVal){
    if (kmVal <= 5){
      const t = smoothStep(clamp(kmVal/5,0,1));
      return lerp(SPAWN_START, SPAWN_5KM, t);
    }
    if (kmVal <= 9){
      const t = smoothStep(clamp((kmVal-5)/4,0,1));
      return lerp(SPAWN_5KM, SPAWN_9KM, t);
    }
    const t = smoothStep(clamp((kmVal-9)/1,0,1));
    return lerp(SPAWN_9KM, SPAWN_10KM, t);
  }

  function gapAt(kmVal){
    const g0 = gapStart(H());
    const g1 = gapEnd(H());
    const t = smoothStep(clamp(kmVal/10, 0, 1));
    return lerp(g0, g1, t);
  }

  // ---------- Spawning ----------
  function spawnObstacle(){
    const w = rand(58, 78);
    const gapH = gapAt(km());
    const margin = Math.max(70, H()*0.14);

    // gapY is top of gap
    const minY = margin;
    const maxY = H() - margin - gapH;
    const gapY = rand(minY, maxY);

    obstacles.push({
      x: W() + rand(80, 140),
      gapY,
      gapH,
      w,
      seed: Math.random()*10,
      hue: rand(330, 40) // coral-ish range
    });
  }

  function spawnFish(initial=false){
    const y = rand(H()*0.16, H()*0.86);
    swimmers.push({
      x: initial ? rand(0,W()) : W() + rand(40, 240),
      y,
      s: rand(0.65, 1.2),
      hue: rand(0, 360),
      phase: Math.random()*10,
      speedK: rand(0.10, 0.26),
      kind: Math.random()<0.75 ? "fish" : "special"
    });
  }

  function spawnBubble(x,y,r){
    bubbles.push({
      x: x + rand(-6,6),
      y: y + rand(-6,6),
      r,
      vx: rand(-14, 14),
      vy: rand(-80, -140),
      life: 0,
      maxLife: rand(0.9, 1.6)
    });
    if (bubbles.length > 160) bubbles.splice(0, bubbles.length-160);
  }

  function applyKmDecor(kmInt){
    // add a few fish on milestones
    if (kmInt % 2 === 0) spawnFish(false);
    if (kmInt % 3 === 0) spawnFish(false);
  }

  // ---------- Collision ----------
  function circleRect(cx,cy,cr, rx,ry,rw,rh){
    const nx = clamp(cx, rx, rx+rw);
    const ny = clamp(cy, ry, ry+rh);
    const dx = cx-nx, dy=cy-ny;
    return dx*dx + dy*dy <= cr*cr;
  }

  function takeHit(){
    if (state.inv>0) return;
    state.lives -= 1;
    state.inv = HIT_INVINCIBLE;
    state.shake = 10;
    for (let i=0;i<12;i++) spawnBubble(octo.x, octo.y, rand(2,5));
    if (state.lives<=0){
      state.over = true;
      if (state.score > state.best){
        state.best = state.score;
        localStorage.setItem("octoFlapBest2", String(state.best));
      }
    }
  }

  // ---------- Drawing ----------
  function drawBackground(){
    const w=W(), h=H();

    // gradient ocean
    const g = ctx.createLinearGradient(0,0,0,h);
    g.addColorStop(0, "#35fff0");
    g.addColorStop(0.30, "#1b9dff");
    g.addColorStop(0.70, "#0a2f66");
    g.addColorStop(1, "#021024");
    ctx.fillStyle = g;
    ctx.fillRect(0,0,w,h);

    // caustics
    ctx.globalAlpha = 0.16;
    ctx.fillStyle = "#ffffff";
    const t = state.t;
    for (let i=0;i<7;i++){
      const yy = h*(0.12 + i*0.085) + Math.sin(t*0.95 + i*0.7)*10;
      ctx.beginPath();
      ctx.ellipse(w/2 + Math.sin(t*0.45+i)*90, yy, w*0.60, 26+Math.sin(t*1.2+i)*10, 0.08, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;

    // parallax reef silhouettes
    layers.forEach((L, idx) => {
      L.x -= state.speed * L.speed * state.dt;
      if (L.x < -w) L.x += w;

      ctx.globalAlpha = L.alpha;
      ctx.fillStyle = idx===0 ? "#0b3a5e" : idx===1 ? "#072d4d" : "#05223d";
      const baseY = h*0.92;
      for (let rep=-1; rep<=1; rep++) {
        const ox = L.x + rep*w;
        ctx.beginPath();
        ctx.moveTo(ox, h);
        for (let x=0; x<=w; x+=44) {
          const yy = baseY - (100 + idx*54) + Math.sin((x*0.012) + t*0.62 + idx)*L.amp;
          ctx.lineTo(ox + x, yy);
        }
        ctx.lineTo(ox + w, h);
        ctx.closePath();
        ctx.fill();
      }
      ctx.globalAlpha = 1;
    });

    // subtle floating particles
    if (Math.random() < 0.08) spawnBubble(rand(0,w), rand(h*0.30, h*0.92), rand(1.6,3.2));
  }

  function drawCoralPillar(x, y, w, h, hue, seed, flip=false){
    // organic coral shape using path; h is pillar height (top or bottom)
    // flip=false draws downwards from y to y+h; flip=true draws upwards ending at y (for top pillar)
    const t = state.t;
    const sway = Math.sin(t*1.2 + seed) * 4;

    ctx.save();
    if (flip){
      ctx.translate(0, y);
      ctx.scale(1, -1);
      y = 0;
    }

    const grad = ctx.createLinearGradient(x, y, x+w, y+h);
    grad.addColorStop(0, `hsla(${hue}, 92%, 62%, 0.96)`);
    grad.addColorStop(1, `hsla(${(hue+30)%360}, 92%, 52%, 0.96)`);
    ctx.fillStyle = grad;

    ctx.beginPath();
    ctx.moveTo(x, y+h);
    ctx.lineTo(x, y + h*0.20);
    ctx.quadraticCurveTo(x + w*0.10 + sway, y + h*0.10, x + w*0.32 + sway*0.6, y + h*0.08);
    ctx.quadraticCurveTo(x + w*0.55 + sway, y + h*0.06, x + w*0.70 - sway*0.3, y + h*0.14);
    ctx.quadraticCurveTo(x + w*0.90 - sway, y + h*0.22, x + w, y + h*0.18);
    ctx.lineTo(x + w, y + h);
    ctx.closePath();
    ctx.fill();

    // branches / bumps
    ctx.globalAlpha = 0.65;
    ctx.fillStyle = `hsla(${(hue+12)%360}, 92%, 72%, 0.80)`;
    for (let i=0;i<4;i++){
      const bx = x + w*(0.18 + i*0.22) + Math.sin(seed+i)*3;
      const by = y + h*(0.26 + i*0.16);
      const bw = w*rand(0.16, 0.26);
      const bh = h*rand(0.08, 0.14);
      ctx.beginPath();
      ctx.ellipse(bx, by, bw, bh, rand(-0.6,0.6), 0, Math.PI*2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;

    // outline
    ctx.strokeStyle = "rgba(0,0,0,0.14)";
    ctx.lineWidth = 2;
    ctx.stroke();

    // small glow highlights
    ctx.globalAlpha = 0.35;
    ctx.fillStyle = "rgba(255,255,255,0.8)";
    ctx.beginPath();
    ctx.roundRect(x+w*0.18, y+h*0.25, w*0.14, h*0.50, 10);
    ctx.fill();
    ctx.globalAlpha = 1;

    ctx.restore();
  }

  function drawObstacle(o){
    // top coral: from 0 to gapY
    const topH = o.gapY;
    const botY = o.gapY + o.gapH;
    const botH = H() - botY;

    // shadows (very soft)
    ctx.globalAlpha = 0.10;
    ctx.fillStyle = "#000";
    ctx.fillRect(o.x+6, 0, o.w, topH);
    ctx.fillRect(o.x+6, botY, o.w, botH);
    ctx.globalAlpha = 1;

    // actual corals
    if (topH > 12) drawCoralPillar(o.x, topH, o.w, topH, o.hue, o.seed, true);
    if (botH > 12) drawCoralPillar(o.x, botY, o.w, botH, o.hue, o.seed+1.7, false);
  }

  function drawSwimmer(s){
    const t = state.t;
    const bob = Math.sin(t*1.2 + s.phase) * 6;
    const x = s.x, y = s.y + bob;
    const scale = s.s;

    ctx.save();
    ctx.translate(x, y);
    ctx.scale(scale, scale);

    if (s.kind === "fish"){
      const body = `hsla(${s.hue}, 92%, 62%, 0.95)`;
      const fin  = `hsla(${(s.hue+40)%360}, 92%, 55%, 0.95)`;
      ctx.fillStyle = body;
      ctx.beginPath(); ctx.ellipse(0,0,18,10,0,0,Math.PI*2); ctx.fill();
      ctx.fillStyle = fin;
      ctx.beginPath();
      ctx.moveTo(-16,0); ctx.lineTo(-30,-10); ctx.lineTo(-30,10); ctx.closePath();
      ctx.fill();
      ctx.fillStyle = "#0a1c2d";
      ctx.beginPath(); ctx.arc(8,-2,2.3,0,Math.PI*2); ctx.fill();
      ctx.fillStyle = "rgba(255,255,255,0.65)";
      ctx.beginPath(); ctx.arc(9,-3,1.0,0,Math.PI*2); ctx.fill();
    } else {
      ctx.fillStyle = `hsla(${s.hue}, 88%, 64%, 0.95)`;
      ctx.beginPath(); ctx.ellipse(0,0,18,14,0,0,Math.PI*2); ctx.fill();
      ctx.strokeStyle = "rgba(255,255,255,0.45)";
      ctx.lineWidth = 2;
      for (let i=0;i<7;i++){
        const a = i*(Math.PI*2/7);
        ctx.beginPath();
        ctx.moveTo(Math.cos(a)*6, Math.sin(a)*5);
        ctx.lineTo(Math.cos(a)*22, Math.sin(a)*16);
        ctx.stroke();
      }
    }

    ctx.restore();
  }

  function drawOcto(){
    const t = state.t;
    octo.phase += state.dt * (state.holding ? 7.5 : 5.5);

    const vy = octo.vy;
    const stretch = clamp((-vy)/900, -0.22, 0.30);
    const squash  = clamp((vy)/1000, 0, 0.22);
    const sx = 1 + squash - stretch*0.25;
    const sy = 1 - squash + stretch;

    const invFlash = (state.inv>0) ? (Math.sin(t*24)>0 ? 0.35 : 1.0) : 1.0;
    const hue = 185 + Math.sin(t*0.6)*18;

    // shadow
    ctx.globalAlpha = 0.12 * invFlash;
    ctx.fillStyle = "#000";
    ctx.beginPath();
    ctx.ellipse(octo.x, octo.y + 34, 22, 10, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;

    ctx.save();
    ctx.translate(octo.x, octo.y);
    ctx.scale(sx, sy);
    ctx.globalAlpha = invFlash;

    // body
    ctx.fillStyle = `hsl(${hue}, 86%, 60%)`;
    ctx.beginPath();
    ctx.ellipse(0, 0, 22, 18, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(0, -16, 18, 16, 0, 0, Math.PI*2);
    ctx.fill();

    // tentacles animate
    ctx.strokeStyle = `hsla(${hue}, 86%, 56%, 0.95)`;
    ctx.lineWidth = 7;
    ctx.lineCap = "round";
    for (let i=0;i<5;i++){
      const a = -1.1 + i*0.55;
      const sway = Math.sin(octo.phase + i*1.1) * 6;
      const x0 = Math.cos(a)*8;
      const y0 = 10;
      const x1 = x0 + sway;
      const y1 = 28 + i*1.4;
      ctx.beginPath();
      ctx.moveTo(x0,y0);
      ctx.quadraticCurveTo(x1*0.6, y1*0.65, x1, y1);
      ctx.stroke();
    }

    // face
    octo.blink -= state.dt;
    if (octo.blink<=0 && Math.random()<0.012) octo.blink = 0.11;

    if (octo.blink>0){
      ctx.strokeStyle = "#062033";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(-10,-18); ctx.lineTo(-4,-18);
      ctx.moveTo(4,-18);  ctx.lineTo(10,-18);
      ctx.stroke();
    } else {
      ctx.fillStyle = "#062033";
      ctx.beginPath();
      ctx.arc(-7,-18,3.2,0,Math.PI*2);
      ctx.arc(7,-18,3.2,0,Math.PI*2);
      ctx.fill();
      ctx.fillStyle = "rgba(255,255,255,0.7)";
      ctx.beginPath();
      ctx.arc(-6,-19,1.1,0,Math.PI*2);
      ctx.arc(8,-19,1.1,0,Math.PI*2);
      ctx.fill();
    }

    ctx.strokeStyle = "rgba(6,32,51,0.9)";
    ctx.lineWidth = 3;
    ctx.lineCap="round";
    ctx.beginPath();
    ctx.arc(0,-8,8,0.15*Math.PI,0.85*Math.PI);
    ctx.stroke();

    ctx.globalAlpha = 1;
    ctx.restore();
  }

  function drawBubbles(){
    ctx.globalAlpha = 0.75;
    ctx.fillStyle = "rgba(255,255,255,0.85)";
    for (const b of bubbles){
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 0.18;
      ctx.beginPath();
      ctx.arc(b.x - b.r*0.3, b.y - b.r*0.3, b.r*0.35, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 0.75;
    }
    ctx.globalAlpha = 1;
  }

  function drawHUD(){
    const pad=14;

    ctx.fillStyle="rgba(0,0,0,0.26)";
    ctx.beginPath();
    ctx.roundRect(pad,pad,260,78,14);
    ctx.fill();

    ctx.fillStyle="rgba(255,255,255,0.94)";
    ctx.font="800 18px system-ui, -apple-system, Segoe UI, Roboto";
    ctx.fillText(`Punti: ${state.score}`, pad+14, pad+28);

    ctx.fillStyle="rgba(255,255,255,0.82)";
    ctx.font="650 14px system-ui, -apple-system, Segoe UI, Roboto";
    ctx.fillText(`Distanza: ${km().toFixed(2)} km`, pad+14, pad+50);

    ctx.fillText(`Vite: ${"❤".repeat(Math.max(0, Math.min(8, state.lives)))}${state.lives>8 ? " +" : ""}`, pad+14, pad+70);

    ctx.textAlign="right";
    ctx.fillStyle="rgba(255,255,255,0.88)";
    ctx.font="700 14px system-ui, -apple-system, Segoe UI, Roboto";
    ctx.fillText(`Best: ${state.best}`, W()-pad, pad+22);
    ctx.textAlign="left";

    if (!state.started && !state.over){
      ctx.fillStyle="rgba(255,255,255,0.95)";
      ctx.font="900 30px system-ui, -apple-system, Segoe UI, Roboto";
      ctx.fillText("POLPO IN FUGA", pad, H()*0.20);
      ctx.fillStyle="rgba(255,255,255,0.84)";
      ctx.font="650 16px system-ui, -apple-system, Segoe UI, Roboto";
      ctx.fillText("Tap o tieni premuto per salire", pad, H()*0.20+34);
      ctx.fillText("Rilascia per scendere", pad, H()*0.20+54);
    }

    if (state.over){
      ctx.textAlign="center";
      ctx.fillStyle="rgba(0,0,0,0.45)";
      ctx.fillRect(0,0,W(),H());

      ctx.fillStyle="rgba(255,255,255,0.95)";
      ctx.font="950 34px system-ui, -apple-system, Segoe UI, Roboto";
      ctx.fillText("GAME OVER", W()/2, H()*0.34);

      ctx.fillStyle="rgba(255,255,255,0.90)";
      ctx.font="750 18px system-ui, -apple-system, Segoe UI, Roboto";
      ctx.fillText(`Punti: ${state.score} • Best: ${state.best}`, W()/2, H()*0.34+34);

      const bw=Math.min(270, W()*0.64), bh=54;
      const bx=(W()-bw)/2, by=H()*0.62;
      ctx.fillStyle="rgba(80,255,210,0.95)";
      ctx.beginPath(); ctx.roundRect(bx,by,bw,bh,16); ctx.fill();

      ctx.fillStyle="rgba(2,16,36,0.95)";
      ctx.font="950 18px system-ui, -apple-system, Segoe UI, Roboto";
      ctx.fillText("RESTART", W()/2, by+34);
      ctx.textAlign="left";
    }
  }

  // roundRect polyfill (older browsers)
  if (!CanvasRenderingContext2D.prototype.roundRect) {
    CanvasRenderingContext2D.prototype.roundRect = function(x,y,w,h,r){
      r=Math.min(r,w/2,h/2);
      this.beginPath();
      this.moveTo(x+r,y);
      this.arcTo(x+w,y,x+w,y+h,r);
      this.arcTo(x+w,y+h,x,y+h,r);
      this.arcTo(x,y+h,x,y,r);
      this.arcTo(x,y,x+w,y,r);
      this.closePath();
      return this;
    };
  }

  // ---------- Update loop ----------
  function step(ts){
    if (!state.lastTs) state.lastTs = ts;
    state.dt = Math.min(0.033, (ts - state.lastTs)/1000);
    state.lastTs = ts;
    state.t += state.dt;

    if (state.inv>0) state.inv = Math.max(0, state.inv - state.dt);

    const kmVal = km();
    const targetSpeed = speedAt(kmVal);
    state.speed += (targetSpeed - state.speed) * (1 - Math.pow(0.001, state.dt));

    const spawnInterval = spawnIntervalAt(kmVal);

    if (state.started && !state.over){
      // distance + score
      state.distancePx += state.speed * state.dt;

      const kmNow = Math.floor(state.distancePx / KM_PX);
      if (kmNow > state.kmCount){
        const delta = kmNow - state.kmCount;
        state.kmCount = kmNow;
        state.score += delta * POINTS_PER_KM;

        for (let k=state.addedUpToKm+1; k<=kmNow; k++){
          applyKmDecor(k);
          state.addedUpToKm = k;
        }

        if (kmNow > 0 && kmNow % LIFE_EVERY_KM === 0){
          state.lives += 1;
          for (let i=0;i<10;i++) spawnBubble(octo.x, octo.y, rand(2,5));
        }
      }

      // spawn obstacles (after safe warmup)
      state.spawnTimer -= state.dt;
      const okWarmup = state.t > SAFE_START_TIME;

      // avoid impossible back-to-back
      const last = obstacles[obstacles.length-1];
      const minGapX = Math.max(260, state.speed * 0.95);
      const okGap = !last || (W() + 120) - last.x >= minGapX;

      if (okWarmup && state.spawnTimer <= 0 && okGap){
        spawnObstacle();
        state.spawnTimer = spawnInterval + rand(-0.10, 0.22);
      }

      // vertical physics: hold = extra lift (capped)
      let ay = GRAVITY;
      if (state.holding){
        state.holdTime += state.dt;
        if (state.holdTime <= HOLD_MAX_TIME){
          const k = clamp(0.85 + state.holdTime*1.2, 0.85, 1.20);
          ay = GRAVITY - HOLD_THRUST*k;
          if (Math.random()<0.22) spawnBubble(octo.x-12, octo.y+10, rand(2,4));
        } else {
          // after cap, behave like normal gravity (prevents "rocket")
          ay = GRAVITY;
        }
      } else {
        state.holdTime = 0;
      }

      octo.vy += ay * state.dt;
      octo.vy = clamp(octo.vy, VY_UP_CAP, VY_DOWN_CAP);
      octo.y += octo.vy * state.dt;

      // top/bottom boundaries: hit costs life but not instant death
      const margin = 34;
      if (octo.y < margin){
        octo.y = margin;
        octo.vy = 120;
        takeHit();
      }
      if (octo.y > H()-margin){
        octo.y = H()-margin;
        octo.vy = -180;
        takeHit();
      }

      // move obstacles
      for (let i=obstacles.length-1; i>=0; i--){
        const o = obstacles[i];
        o.x -= state.speed * state.dt;
        if (o.x + o.w < -120) obstacles.splice(i,1);
      }

      // swimmers
      for (let i=swimmers.length-1; i>=0; i--){
        const s = swimmers[i];
        s.x -= state.speed * s.speedK * state.dt;
        if (s.x < -240) swimmers.splice(i,1);
      }
      if (swimmers.filter(s=>s.kind==="fish").length < 10) spawnFish(false);

      // bubbles
      for (let i=bubbles.length-1; i>=0; i--){
        const b = bubbles[i];
        b.life += state.dt;
        b.x += b.vx * state.dt;
        b.y += b.vy * state.dt;
        b.vx += Math.sin(state.t*2 + i)*3 * state.dt;
        if (b.life > b.maxLife || b.y < -40) bubbles.splice(i,1);
      }

      // collision with obstacles: treat pillars as rects for hit-test (forgiving padding)
      const cr = 18;
      const cx = octo.x, cy = octo.y;

      for (const o of obstacles){
        const ox = o.x, ow = o.w;
        const topRect = {x: ox+6, y: 0, w: ow-12, h: o.gapY-4};
        const botRect = {x: ox+6, y: o.gapY + o.gapH + 4, w: ow-12, h: H() - (o.gapY + o.gapH) - 4};

        if (circleRect(cx,cy,cr, topRect.x, topRect.y, topRect.w, topRect.h) ||
            circleRect(cx,cy,cr, botRect.x, botRect.y, botRect.w, botRect.h)){
          takeHit();
          break;
        }
      }
    } else {
      // idle float
      octo.y = lerp(octo.y, H()*0.52, 1 - Math.pow(0.001, state.dt));
      octo.vy = 0;
    }

    // screen shake
    let shx=0, shy=0;
    if (state.shake>0){
      state.shake = Math.max(0, state.shake - state.dt*20);
      const s = state.shake;
      shx = (Math.random()*2-1)*s;
      shy = (Math.random()*2-1)*s;
    }

    // ---------- Render ----------
    ctx.save();
    ctx.translate(shx, shy);

    drawBackground();

    // swimmers
    for (const s of swimmers) drawSwimmer(s);

    // obstacles
    for (const o of obstacles) drawObstacle(o);

    // octo
    drawOcto();

    // bubbles
    drawBubbles();

    // HUD
    drawHUD();

    ctx.restore();

    requestAnimationFrame(step);
  }

  reset();
  requestAnimationFrame(step);

})();
</script>
</body>
</html>
