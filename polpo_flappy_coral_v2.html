<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover" />
  <meta name="theme-color" content="#021024" />
  <title>Polpo in Fuga</title>
  <style>
    html, body { margin:0; padding:0; height:100%; overflow:hidden; background:#021024; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    canvas { width:100vw; height:100vh; display:block; touch-action: none; }
  </style>
</head>
<body>
<canvas id="c"></canvas>

<script>
(() => {
  "use strict";

  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha:false });

  function resize() {
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    canvas.width  = Math.floor(innerWidth  * dpr);
    canvas.height = Math.floor(innerHeight * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  addEventListener("resize", resize, { passive:true });
  resize();

  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const rand=(a,b)=>a+Math.random()*(b-a);
  const lerp=(a,b,t)=>a+(b-a)*t;
  const smoothStep=t=>t*t*(3-2*t);

  const KM_PX = 1100;
  const POINTS_PER_KM = 100;

  const START_LIVES = 3;
  const BONUS_START_KM = 30;
  const BONUS_EVERY_KM = 10;

  const HIT_INVINCIBLE = 1.00;

  const GRAVITY = 1380;
  const HOLD_THRUST = 2550;
  const TAP_IMPULSE = -260;
  const HOLD_MAX_TIME = 0.22;
  const VY_UP_CAP = -540;
  const VY_DOWN_CAP = 820;

  const SPEED_0KM   = 240;
  const SPEED_5KM   = 320;
  const SPEED_10KM  = 395;
  const SPEED_20KM  = 470;
  const SPEED_30KM  = 545;
  const SPEED_40KM  = 600;

  function gapAt(kmVal, H){
    const g0 = clamp(H*0.36, 220, 330);
    const g10 = clamp(H*0.32, 200, 300);
    const g20 = clamp(H*0.29, 180, 270);
    const g30 = clamp(H*0.26, 165, 250);
    const g40 = clamp(H*0.24, 150, 235);

    if (kmVal <= 10){
      const t = smoothStep(clamp(kmVal/10,0,1));
      return lerp(g0, g10, t);
    }
    if (kmVal <= 20){
      const t = smoothStep(clamp((kmVal-10)/10,0,1));
      return lerp(g10, g20, t);
    }
    if (kmVal <= 30){
      const t = smoothStep(clamp((kmVal-20)/10,0,1));
      return lerp(g20, g30, t);
    }
    const t = smoothStep(clamp((kmVal-30)/10,0,1));
    return lerp(g30, g40, t);
  }

  function spawnIntervalAt(kmVal){
    const s0 = 1.45, s10 = 1.15, s20 = 0.98, s30 = 0.88, s40 = 0.82;
    if (kmVal <= 10){
      const t = smoothStep(clamp(kmVal/10,0,1));
      return lerp(s0, s10, t);
    }
    if (kmVal <= 20){
      const t = smoothStep(clamp((kmVal-10)/10,0,1));
      return lerp(s10, s20, t);
    }
    if (kmVal <= 30){
      const t = smoothStep(clamp((kmVal-20)/10,0,1));
      return lerp(s20, s30, t);
    }
    const t = smoothStep(clamp((kmVal-30)/10,0,1));
    return lerp(s30, s40, t);
  }

  const SAFE_START_TIME = 1.10;

  const state = {
    started:false,
    over:false,
    t:0, dt:0, lastTs:0,

    speed:SPEED_0KM,
    spawnTimer:0,
    distancePx:0,
    kmCount:0,
    score:0,
    best:Number(localStorage.getItem("octoFlapBest3")||0),

    lives:START_LIVES,
    inv:0,

    holding:false,
    holdTime:0,

    shake:0,
    addedUpToKm:-1
  };

  const octo = { x:0, y:0, vy:0, blink:0, phase:0 };
  const obstacles = [];
  const swimmers = [];
  const bubbles = [];

  const layers = [
    { x:0, speed:0.12, amp:14, alpha:0.22 },
    { x:0, speed:0.22, amp:20, alpha:0.18 },
    { x:0, speed:0.36, amp:26, alpha:0.14 }
  ];

  const W = () => innerWidth;
  const H = () => innerHeight;
  const km = () => state.distancePx / KM_PX;

  function speedAt(kmVal){
    if (kmVal <= 5){
      const t = smoothStep(clamp(kmVal/5,0,1));
      return lerp(SPEED_0KM, SPEED_5KM, t);
    }
    if (kmVal <= 10){
      const t = smoothStep(clamp((kmVal-5)/5,0,1));
      return lerp(SPEED_5KM, SPEED_10KM, t);
    }
    if (kmVal <= 20){
      const t = smoothStep(clamp((kmVal-10)/10,0,1));
      return lerp(SPEED_10KM, SPEED_20KM, t);
    }
    if (kmVal <= 30){
      const t = smoothStep(clamp((kmVal-20)/10,0,1));
      return lerp(SPEED_20KM, SPEED_30KM, t);
    }
    const t = smoothStep(clamp((kmVal-30)/10,0,1));
    return lerp(SPEED_30KM, SPEED_40KM, t);
  }

  function reset() {
    state.started=false;
    state.over=false;
    state.t=0; state.dt=0; state.lastTs=0;

    state.speed=SPEED_0KM;
    state.spawnTimer=0.65;
    state.distancePx=0;
    state.kmCount=0;
    state.score=0;

    state.lives=START_LIVES;
    state.inv=0;
    state.holding=false;
    state.holdTime=0;

    state.shake=0;
    state.addedUpToKm=-1;

    obstacles.length=0;
    swimmers.length=0;
    bubbles.length=0;

    octo.x = Math.max(90, W()*0.26);
    octo.y = H()*0.52;
    octo.vy = 0;
    octo.blink = 0;
    octo.phase = 0;

    for (let i=0;i<10;i++) spawnFish(true);
  }

  function startIfNeeded(){ if (!state.started && !state.over) state.started = true; }

  function down() {
    if (state.over) return;
    startIfNeeded();
    state.holding = true;
    state.holdTime = 0;
    octo.vy = Math.min(octo.vy, 140);
    octo.vy += TAP_IMPULSE;
    for (let i=0;i<5;i++) spawnBubble(octo.x-10, octo.y+8, rand(2,4));
  }
  function up() { state.holding = false; state.holdTime = 0; }

  function restartTap(x,y){
    if (!state.over) return false;
    const bw=Math.min(270, W()*0.64), bh=54;
    const bx=(W()-bw)/2, by=H()*0.62;
    return x>=bx && x<=bx+bw && y>=by && y<=by+bh;
  }

  function getXY(ev){
    const rect = canvas.getBoundingClientRect();
    const p = (ev.touches && ev.touches[0]) ? ev.touches[0] : ev;
    return { x:(p.clientX ?? 0) - rect.left, y:(p.clientY ?? 0) - rect.top };
  }

  canvas.addEventListener("pointerdown", (ev)=>{
    const {x,y}=getXY(ev);
    if (restartTap(x,y)) { reset(); return; }
    down();
  }, { passive:true });
  canvas.addEventListener("pointerup", up, { passive:true });
  canvas.addEventListener("pointercancel", up, { passive:true });
  canvas.addEventListener("touchstart", (e)=>{ e.preventDefault(); }, { passive:false });

  addEventListener("keydown", (e)=>{
    if (e.code==="Space" || e.code==="ArrowUp") { e.preventDefault(); if (state.over){ reset(); return; } down(); }
  });
  addEventListener("keyup", (e)=>{
    if (e.code==="Space" || e.code==="ArrowUp") { e.preventDefault(); up(); }
  });

  function spawnObstacle(){
    const w = rand(64, 86);
    const kmVal = km();
    const gapH = gapAt(kmVal, H());
    const margin = Math.max(86, H()*0.16);

    const minY = margin;
    const maxY = H() - margin - gapH;
    const gapY = rand(minY, maxY);

    const palette = [rand(330, 360), rand(0, 40), rand(150, 190), rand(40, 70)];
    const hue = palette[Math.floor(Math.random()*palette.length)];
    obstacles.push({
      x: W() + rand(90, 150),
      gapY, gapH, w,
      seed: Math.random()*10,
      hue,
      variant: Math.random()<0.5 ? "branch" : "fan"
    });
  }

  function spawnFish(initial=false){
    const y = rand(H()*0.16, H()*0.86);
    swimmers.push({
      x: initial ? rand(0,W()) : W() + rand(40, 240),
      y,
      s: rand(0.65, 1.2),
      hue: rand(0, 360),
      phase: Math.random()*10,
      speedK: rand(0.10, 0.26),
      kind: Math.random()<0.78 ? "fish" : "special"
    });
  }

  function spawnBubble(x,y,r){
    bubbles.push({ x:x+rand(-6,6), y:y+rand(-6,6), r, vx:rand(-12,12), vy:rand(-70,-130), life:0, maxLife:rand(1.0,1.8) });
    if (bubbles.length > 180) bubbles.splice(0, bubbles.length-180);
  }

  function applyKmDecor(kmInt){
    if (kmInt % 2 === 0) spawnFish(false);
    if (kmInt % 5 === 0) spawnFish(false);
  }

  function circleRect(cx,cy,cr, rx,ry,rw,rh){
    const nx = clamp(cx, rx, rx+rw);
    const ny = clamp(cy, ry, ry+rh);
    const dx = cx-nx, dy=cy-ny;
    return dx*dx + dy*dy <= cr*cr;
  }

  function takeHit(){
    if (state.inv>0) return;
    state.lives -= 1;
    state.inv = HIT_INVINCIBLE;
    state.shake = 10;
    for (let i=0;i<12;i++) spawnBubble(octo.x, octo.y, rand(2,5));
    if (state.lives<=0){
      state.over = true;
      if (state.score > state.best){
        state.best = state.score;
        localStorage.setItem("octoFlapBest3", String(state.best));
      }
    }
  }

  function drawBackground(){
    const w=W(), h=H();
    const g = ctx.createLinearGradient(0,0,0,h);
    g.addColorStop(0, "#6ff7ff");
    g.addColorStop(0.25, "#52c8ff");
    g.addColorStop(0.55, "#2b7cff");
    g.addColorStop(1, "#0b1b42");
    ctx.fillStyle = g;
    ctx.fillRect(0,0,w,h);

    ctx.globalAlpha = 0.22;
    for (let i=0;i<5;i++){
      const yy = h*(0.18 + i*0.12) + Math.sin(state.t*0.6 + i)*14;
      const gg = ctx.createLinearGradient(0, yy, w, yy);
      gg.addColorStop(0, "rgba(255,255,255,0)");
      gg.addColorStop(0.5, "rgba(255,255,255,1)");
      gg.addColorStop(1, "rgba(255,255,255,0)");
      ctx.fillStyle = gg;
      ctx.beginPath();
      ctx.ellipse(w/2 + Math.sin(state.t*0.35+i)*90, yy, w*0.62, 26, 0, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;

    ctx.globalAlpha = 0.10;
    ctx.fillStyle = "rgba(255,255,255,0.9)";
    for (let i=0;i<6;i++){
      const yy = h*(0.12 + i*0.10) + Math.sin(state.t*0.95 + i*0.7)*10;
      ctx.beginPath();
      ctx.ellipse(w/2 + Math.sin(state.t*0.45+i)*90, yy, w*0.58, 18+Math.sin(state.t*1.2+i)*8, 0.08, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;

    layers.forEach((L, idx) => {
      L.x -= state.speed * L.speed * state.dt;
      if (L.x < -w) L.x += w;

      ctx.globalAlpha = L.alpha;
      ctx.fillStyle = idx===0 ? "#0d3a66" : idx===1 ? "#0a2f57" : "#072449";
      const baseY = h*0.96;
      for (let rep=-1; rep<=1; rep++) {
        const ox = L.x + rep*w;
        ctx.beginPath();
        ctx.moveTo(ox, h);
        for (let x=0; x<=w; x+=56) {
          const yy = baseY - (120 + idx*60) + Math.sin((x*0.010) + state.t*0.55 + idx)*L.amp;
          ctx.quadraticCurveTo(ox+x+28, yy-20, ox+x+56, yy);
        }
        ctx.lineTo(ox + w, h);
        ctx.closePath();
        ctx.fill();
      }
      ctx.globalAlpha = 1;
    });

    if (Math.random() < 0.07) spawnBubble(rand(0,w), rand(h*0.30, h*0.92), rand(1.6,3.0));
  }

  function drawCoralPillar(x, y, w, h, hue, seed, flip=false, variant="branch"){
    const sway = Math.sin(state.t*0.8 + seed) * 3;

    ctx.save();
    if (flip){
      ctx.translate(0, y);
      ctx.scale(1, -1);
      y = 0;
    }

    const grad = ctx.createLinearGradient(x, y, x+w, y+h);
    grad.addColorStop(0, `hsla(${hue}, 92%, 62%, 0.98)`);
    grad.addColorStop(1, `hsla(${(hue+25)%360}, 92%, 50%, 0.98)`);
    ctx.fillStyle = grad;

    ctx.beginPath();
    ctx.moveTo(x, y+h);
    ctx.lineTo(x, y + h*0.20);
    ctx.bezierCurveTo(
      x + w*0.12 + sway, y + h*0.02,
      x + w*0.58 + sway*0.5, y + h*0.02,
      x + w, y + h*0.22
    );
    ctx.lineTo(x + w, y + h);
    ctx.closePath();
    ctx.fill();

    ctx.globalAlpha = 0.9;
    ctx.fillStyle = `hsla(${(hue+12)%360}, 92%, 70%, 0.85)`;
    const arms = variant==="fan" ? 5 : 4;
    for (let i=0;i<arms;i++){
      const ax = x + w*(0.18 + i*(0.64/(arms-1)));
      const ay = y + h*(variant==="fan" ? 0.28 : 0.38) + i*4;
      const aw = w*rand(0.14, 0.24);
      const ah = h*rand(0.10, 0.18);
      ctx.beginPath();
      ctx.ellipse(ax + Math.sin(seed+i)*2, ay, aw, ah, rand(-0.8,0.8), 0, Math.PI*2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;

    ctx.strokeStyle = "rgba(0,0,0,0.14)";
    ctx.lineWidth = 2;
    ctx.stroke();

    ctx.globalAlpha = 0.22;
    ctx.fillStyle = "rgba(255,255,255,0.9)";
    ctx.beginPath();
    ctx.roundRect(x+w*0.18, y+h*0.28, w*0.10, h*0.44, 10);
    ctx.fill();
    ctx.globalAlpha = 1;

    ctx.restore();
  }

  function drawObstacle(o){
    const topH = o.gapY;
    const botY = o.gapY + o.gapH;
    const botH = H() - botY;

    ctx.globalAlpha = 0.08;
    ctx.fillStyle = "#000";
    ctx.fillRect(o.x+8, 0, o.w, topH);
    ctx.fillRect(o.x+8, botY, o.w, botH);
    ctx.globalAlpha = 1;

    if (topH > 10) drawCoralPillar(o.x, topH, o.w, topH, o.hue, o.seed, true, o.variant);
    if (botH > 10) drawCoralPillar(o.x, botY, o.w, botH, o.hue, o.seed+1.7, false, o.variant);
  }

  function drawSwimmer(s){
    const bob = Math.sin(state.t*1.2 + s.phase) * 6;
    const x = s.x, y = s.y + bob;
    const scale = s.s;

    ctx.save();
    ctx.translate(x, y);
    ctx.scale(scale, scale);

    if (s.kind === "fish"){
      const body = `hsla(${s.hue}, 92%, 62%, 0.95)`;
      const fin  = `hsla(${(s.hue+40)%360}, 92%, 55%, 0.95)`;
      ctx.fillStyle = body;
      ctx.beginPath(); ctx.ellipse(0,0,18,10,0,0,Math.PI*2); ctx.fill();
      ctx.fillStyle = fin;
      ctx.beginPath(); ctx.moveTo(-16,0); ctx.lineTo(-30,-10); ctx.lineTo(-30,10); ctx.closePath(); ctx.fill();
      ctx.fillStyle = "#0a1c2d";
      ctx.beginPath(); ctx.arc(8,-2,2.3,0,Math.PI*2); ctx.fill();
      ctx.fillStyle = "rgba(255,255,255,0.65)";
      ctx.beginPath(); ctx.arc(9,-3,1.0,0,Math.PI*2); ctx.fill();
    } else {
      ctx.fillStyle = `hsla(${s.hue}, 88%, 64%, 0.95)`;
      ctx.beginPath(); ctx.ellipse(0,0,18,14,0,0,Math.PI*2); ctx.fill();
      ctx.strokeStyle = "rgba(255,255,255,0.40)";
      ctx.lineWidth = 2;
      for (let i=0;i<7;i++){
        const a = i*(Math.PI*2/7);
        ctx.beginPath();
        ctx.moveTo(Math.cos(a)*6, Math.sin(a)*5);
        ctx.lineTo(Math.cos(a)*22, Math.sin(a)*16);
        ctx.stroke();
      }
      ctx.fillStyle = "#081629";
      ctx.beginPath(); ctx.arc(6,-2,2.3,0,Math.PI*2); ctx.fill();
    }

    ctx.restore();
  }

  function drawOcto(){
    octo.phase += state.dt * (state.holding ? 7.5 : 5.5);

    const vy = octo.vy;
    const stretch = clamp((-vy)/900, -0.22, 0.30);
    const squash  = clamp((vy)/1000, 0, 0.22);
    const sx = 1 + squash - stretch*0.25;
    const sy = 1 - squash + stretch;

    const t = state.t;
    const invFlash = (state.inv>0) ? (Math.sin(t*24)>0 ? 0.35 : 1.0) : 1.0;
    const hue = 185 + Math.sin(t*0.6)*18 + clamp(km()*2.2, 0, 90);

    ctx.globalAlpha = 0.10 * invFlash;
    ctx.fillStyle = "#000";
    ctx.beginPath();
    ctx.ellipse(octo.x, octo.y + 38, 22, 10, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;

    ctx.save();
    ctx.translate(octo.x, octo.y);
    ctx.scale(sx, sy);
    ctx.globalAlpha = invFlash;

    ctx.fillStyle = `hsl(${hue}, 86%, 60%)`;
    ctx.beginPath(); ctx.ellipse(0, 0, 22, 18, 0, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(0, -16, 18, 16, 0, 0, Math.PI*2); ctx.fill();

    ctx.strokeStyle = `hsla(${hue}, 86%, 56%, 0.95)`;
    ctx.lineWidth = 7;
    ctx.lineCap = "round";
    for (let i=0;i<5;i++){
      const a = -1.1 + i*0.55;
      const sway = Math.sin(octo.phase + i*1.1) * 6;
      const x0 = Math.cos(a)*8;
      const y0 = 10;
      const x1 = x0 + sway;
      const y1 = 30 + i*1.5;
      ctx.beginPath();
      ctx.moveTo(x0,y0);
      ctx.quadraticCurveTo(x1*0.6, y1*0.65, x1, y1);
      ctx.stroke();
    }

    octo.blink -= state.dt;
    if (octo.blink<=0 && Math.random()<0.012) octo.blink = 0.11;

    if (octo.blink>0){
      ctx.strokeStyle = "#062033";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(-10,-18); ctx.lineTo(-4,-18);
      ctx.moveTo(4,-18);  ctx.lineTo(10,-18);
      ctx.stroke();
    } else {
      ctx.fillStyle = "#062033";
      ctx.beginPath();
      ctx.arc(-7,-18,3.2,0,Math.PI*2);
      ctx.arc(7,-18,3.2,0,Math.PI*2);
      ctx.fill();
      ctx.fillStyle = "rgba(255,255,255,0.7)";
      ctx.beginPath();
      ctx.arc(-6,-19,1.1,0,Math.PI*2);
      ctx.arc(8,-19,1.1,0,Math.PI*2);
      ctx.fill();
    }

    ctx.strokeStyle = "rgba(6,32,51,0.9)";
    ctx.lineWidth = 3;
    ctx.lineCap="round";
    ctx.beginPath();
    ctx.arc(0,-8,8,0.15*Math.PI,0.85*Math.PI);
    ctx.stroke();

    ctx.globalAlpha = 1;
    ctx.restore();
  }

  function drawBubbles(){
    ctx.globalAlpha = 0.70;
    ctx.fillStyle = "rgba(255,255,255,0.85)";
    for (const b of bubbles){
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 0.14;
      ctx.beginPath();
      ctx.arc(b.x - b.r*0.3, b.y - b.r*0.3, b.r*0.35, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 0.70;
    }
    ctx.globalAlpha = 1;
  }

  function drawHUD(){
    const pad=14;
    const w=W(), h=H();

    ctx.fillStyle="rgba(0,0,0,0.22)";
    ctx.beginPath();
    ctx.roundRect(pad, pad, 250, 74, 18);
    ctx.fill();

    ctx.fillStyle="rgba(111,247,255,0.35)";
    ctx.beginPath();
    ctx.roundRect(pad+10, pad+10, 6, 54, 10);
    ctx.fill();

    ctx.fillStyle="rgba(255,255,255,0.92)";
    ctx.font="800 16px system-ui, -apple-system, Segoe UI, Roboto";
    ctx.fillText("Punteggio", pad+26, pad+28);
    ctx.font="900 24px system-ui, -apple-system, Segoe UI, Roboto";
    ctx.fillText(String(state.score), pad+26, pad+54);

    ctx.font="900 18px system-ui, -apple-system, Segoe UI, Roboto";
    ctx.fillStyle="rgba(255,255,255,0.92)";
    const hearts = "❤".repeat(Math.max(0, Math.min(10, state.lives)));
    ctx.fillText(hearts + (state.lives>10 ? " +" : ""), pad+26, pad+74);

    ctx.textAlign="right";
    ctx.fillStyle="rgba(255,255,255,0.75)";
    ctx.font="700 14px system-ui, -apple-system, Segoe UI, Roboto";
    ctx.fillText(`Best ${state.best}`, w-pad, pad+22);
    ctx.fillStyle="rgba(255,255,255,0.60)";
    ctx.font="650 12px system-ui, -apple-system, Segoe UI, Roboto";
    ctx.fillText(`${km().toFixed(2)} km`, w-pad, pad+40);
    ctx.textAlign="left";

    if (!state.started && !state.over){
      ctx.globalAlpha = 0.35;
      ctx.fillStyle = "#000";
      ctx.fillRect(0,0,w,h);
      ctx.globalAlpha = 1;
      ctx.fillStyle = "rgba(255,255,255,0.92)";
      ctx.font="900 34px system-ui, -apple-system, Segoe UI, Roboto";
      ctx.fillText("POLPO IN FUGA", pad, h*0.22);
      ctx.globalAlpha = 0.55;
      ctx.font="700 14px system-ui, -apple-system, Segoe UI, Roboto";
      ctx.fillText("• • •", pad, h*0.22 + 28);
      ctx.globalAlpha = 1;
    }

    if (state.over){
      ctx.textAlign="center";
      ctx.fillStyle="rgba(0,0,0,0.45)";
      ctx.fillRect(0,0,w,h);

      ctx.fillStyle="rgba(255,255,255,0.95)";
      ctx.font="950 34px system-ui, -apple-system, Segoe UI, Roboto";
      ctx.fillText("GAME OVER", w/2, h*0.34);

      ctx.fillStyle="rgba(255,255,255,0.90)";
      ctx.font="750 18px system-ui, -apple-system, Segoe UI, Roboto";
      ctx.fillText(`Punteggio ${state.score} • Best ${state.best}`, w/2, h*0.34+34);

      const bw=Math.min(270, w*0.64), bh=54;
      const bx=(w-bw)/2, by=h*0.62;
      ctx.fillStyle="rgba(80,255,210,0.95)";
      ctx.beginPath(); ctx.roundRect(bx,by,bw,bh,16); ctx.fill();
      ctx.fillStyle="rgba(2,16,36,0.95)";
      ctx.font="950 18px system-ui, -apple-system, Segoe UI, Roboto";
      ctx.fillText("RESTART", w/2, by+34);
      ctx.textAlign="left";
    }
  }

  if (!CanvasRenderingContext2D.prototype.roundRect) {
    CanvasRenderingContext2D.prototype.roundRect = function(x,y,w,h,r){
      r=Math.min(r,w/2,h/2);
      this.beginPath();
      this.moveTo(x+r,y);
      this.arcTo(x+w,y,x+w,y+h,r);
      this.arcTo(x+w,y+h,x,y+h,r);
      this.arcTo(x,y+h,x,y,r);
      this.arcTo(x,y,x+w,y,r);
      this.closePath();
      return this;
    };
  }

  function step(ts){
    if (!state.lastTs) state.lastTs = ts;
    state.dt = Math.min(0.033, (ts - state.lastTs)/1000);
    state.lastTs = ts;
    state.t += state.dt;

    if (state.inv>0) state.inv = Math.max(0, state.inv - state.dt);

    const kmVal = km();
    const targetSpeed = speedAt(kmVal);
    state.speed += (targetSpeed - state.speed) * (1 - Math.pow(0.001, state.dt));

    const spawnInterval = spawnIntervalAt(kmVal);

    if (state.started && !state.over){
      state.distancePx += state.speed * state.dt;

      const kmNow = Math.floor(state.distancePx / KM_PX);
      if (kmNow > state.kmCount){
        const delta = kmNow - state.kmCount;
        state.kmCount = kmNow;
        state.score += delta * POINTS_PER_KM;

        for (let k=state.addedUpToKm+1; k<=kmNow; k++){
          applyKmDecor(k);
          state.addedUpToKm = k;
        }

        if (kmNow >= BONUS_START_KM and kmNow % BONUS_EVERY_KM == 0){
          // Note: JS uses && and ===; fixed below in runtime check
        }
      }

      // correct JS conditional for bonus heart
      if (kmNow >= BONUS_START_KM && kmNow % BONUS_EVERY_KM === 0){
        // ensure we only grant once per milestone:
        // grant exactly when crossing the milestone (handled by kmNow>kmCount above),
        // but keep guard anyway:
        if (kmNow !== 0){
          state.lives += 1;
          for (let i=0;i<16;i++) spawnBubble(octo.x, octo.y, rand(2,5));
        }
      }

      state.spawnTimer -= state.dt;
      const okWarmup = state.t > SAFE_START_TIME;

      const last = obstacles[obstacles.length-1];
      const minGapX = Math.max(300, state.speed * 0.95);
      const okGap = !last || (W() + 140) - last.x >= minGapX;

      if (okWarmup && state.spawnTimer <= 0 && okGap){
        spawnObstacle();
        state.spawnTimer = spawnInterval + rand(-0.10, 0.22);
      }

      let ay = GRAVITY;
      if (state.holding){
        state.holdTime += state.dt;
        if (state.holdTime <= HOLD_MAX_TIME){
          const k = clamp(0.85 + state.holdTime*1.2, 0.85, 1.20);
          ay = GRAVITY - HOLD_THRUST*k;
          if (Math.random()<0.18) spawnBubble(octo.x-12, octo.y+10, rand(2,4));
        } else {
          ay = GRAVITY;
        }
      } else {
        state.holdTime = 0;
      }

      octo.vy += ay * state.dt;
      octo.vy = clamp(octo.vy, VY_UP_CAP, VY_DOWN_CAP);
      octo.y += octo.vy * state.dt;

      const margin = 38;
      if (octo.y < margin){
        octo.y = margin;
        octo.vy = 140;
        takeHit();
      }
      if (octo.y > H()-margin){
        octo.y = H()-margin;
        octo.vy = -200;
        takeHit();
      }

      for (let i=obstacles.length-1; i>=0; i--){
        const o = obstacles[i];
        o.x -= state.speed * state.dt;
        if (o.x + o.w < -160) obstacles.splice(i,1);
      }

      for (let i=swimmers.length-1; i>=0; i--){
        const s = swimmers[i];
        s.x -= state.speed * s.speedK * state.dt;
        if (s.x < -260) swimmers.splice(i,1);
      }
      if (swimmers.filter(s=>s.kind==="fish").length < 10) spawnFish(false);

      for (let i=bubbles.length-1; i>=0; i--){
        const b = bubbles[i];
        b.life += state.dt;
        b.x += b.vx * state.dt;
        b.y += b.vy * state.dt;
        b.vx += Math.sin(state.t*2 + i)*3 * state.dt;
        if (b.life > b.maxLife || b.y < -50) bubbles.splice(i,1);
      }

      const cr = 18;
      const cx = octo.x, cy = octo.y;

      for (const o of obstacles){
        const ox = o.x, ow = o.w;
        const topRect = {x: ox+8, y: 0, w: ow-16, h: o.gapY-6};
        const botRect = {x: ox+8, y: o.gapY + o.gapH + 6, w: ow-16, h: H() - (o.gapY + o.gapH) - 6};

        if (circleRect(cx,cy,cr, topRect.x, topRect.y, topRect.w, topRect.h) ||
            circleRect(cx,cy,cr, botRect.x, botRect.y, botRect.w, botRect.h)){
          takeHit();
          break;
        }
      }
    } else {
      octo.y = lerp(octo.y, H()*0.52, 1 - Math.pow(0.001, state.dt));
      octo.vy = 0;
    }

    let shx=0, shy=0;
    if (state.shake>0){
      state.shake = Math.max(0, state.shake - state.dt*20);
      const s = state.shake;
      shx = (Math.random()*2-1)*s;
      shy = (Math.random()*2-1)*s;
    }

    ctx.save();
    ctx.translate(shx, shy);
    drawBackground();
    for (const s of swimmers) drawSwimmer(s);
    for (const o of obstacles) drawObstacle(o);
    drawOcto();
    drawBubbles();
    drawHUD();
    ctx.restore();

    requestAnimationFrame(step);
  }

  reset();
  requestAnimationFrame(step);
})();
</script>
</body>
</html>
