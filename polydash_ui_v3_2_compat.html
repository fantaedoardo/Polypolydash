<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover" />
  <meta name="theme-color" content="#021024" />
  <title>Polpo in Fuga</title>
  <style>
    html, body { margin:0; padding:0; height:100%; overflow:hidden; background:#021024; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    canvas { width:100vw; height:100vh; display:block; touch-action: none; }
  </style>
</head>
<body>
<canvas id="c"></canvas>

<script>
(() => {
  "use strict";

  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha:false });

  function resize() {
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    canvas.width  = Math.floor(innerWidth  * dpr);
    canvas.height = Math.floor(innerHeight * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  addEventListener("resize", resize, { passive:true });
  resize();

  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const rand=(a,b)=>a+Math.random()*(b-a);
  const lerp=(a,b,t)=>a+(b-a)*t;
  const smoothStep=t=>t*t*(3-2*t);

  const KM_PX = 1100;
  const POINTS_PER_KM = 100;

  const START_LIVES = 3;
  const BONUS_START_KM = 30;
  const BONUS_EVERY_KM = 10;

  const HIT_INVINCIBLE = 1.00;

  const GRAVITY = 1380;
  const HOLD_THRUST = 2550;
  const TAP_IMPULSE = -260;
  const HOLD_MAX_TIME = 0.22;
  const VY_UP_CAP = -540;
  const VY_DOWN_CAP = 820;

  const SPEED_0KM   = 240;
  const SPEED_5KM   = 320;
  const SPEED_10KM  = 395;
  const SPEED_20KM  = 470;
  const SPEED_30KM  = 545;
  const SPEED_40KM  = 600;

  function gapAt(kmVal, H){
    // gap tightens earlier to avoid long easy phase
    const g0  = clamp(H*0.36, 220, 330);
    const g8  = clamp(H*0.31, 195, 290);
    const g16 = clamp(H*0.28, 175, 265);
    const g26 = clamp(H*0.25, 160, 245);
    const g36 = clamp(H*0.23, 148, 232);

    if (kmVal <= 8){
      const t = smoothStep(clamp(kmVal/8,0,1));
      return lerp(g0, g8, t);
    }
    if (kmVal <= 16){
      const t = smoothStep(clamp((kmVal-8)/8,0,1));
      return lerp(g8, g16, t);
    }
    if (kmVal <= 26){
      const t = smoothStep(clamp((kmVal-16)/10,0,1));
      return lerp(g16, g26, t);
    }
    const t = smoothStep(clamp((kmVal-26)/10,0,1));
    return lerp(g26, g36, t);
  }

  function spawnIntervalAt(kmVal){
    // spawns speed up earlier
    const s0 = 1.45, s8 = 1.10, s16 = 0.95, s26 = 0.86, s36 = 0.80;
    if (kmVal <= 8){
      const t = smoothStep(clamp(kmVal/8,0,1));
      return lerp(s0, s8, t);
    }
    if (kmVal <= 16){
      const t = smoothStep(clamp((kmVal-8)/8,0,1));
      return lerp(s8, s16, t);
    }
    if (kmVal <= 26){
      const t = smoothStep(clamp((kmVal-16)/10,0,1));
      return lerp(s16, s26, t);
    }
    const t = smoothStep(clamp((kmVal-26)/10,0,1));
    return lerp(s26, s36, t);
  }

  const SAFE_START_TIME = 1.10;

  const state = {
    started:false,
    over:false,
    t:0, dt:0, lastTs:0,

    speed:SPEED_0KM,
    spawnTimer:0,
    distancePx:0,
    kmCount:0,
    score:0,
    best:Number(localStorage.getItem("octoFlapBest3")||0),

    lives:START_LIVES,
    inv:0,

    holding:false,
    holdTime:0,

    shake:0,
    addedUpToKm:-1,
    playBtn: { x:0, y:0, r:0 }
  };

  const octo = { x:0, y:0, vy:0, blink:0, phase:0 };
  const obstacles = [];
  const swimmers = [];
  const bubbles = [];

  const layers = [
    { x:0, speed:0.12, amp:14, alpha:0.22 },
    { x:0, speed:0.22, amp:20, alpha:0.18 },
    { x:0, speed:0.36, amp:26, alpha:0.14 }
  ];

  const W = () => innerWidth;
  const H = () => innerHeight;
  const km = () => state.distancePx / KM_PX;

  function speedAt(kmVal){
    // harder earlier: ramps start by ~3km instead of ~5km
    if (kmVal <= 3){
      const t = smoothStep(clamp(kmVal/3,0,1));
      return lerp(SPEED_0KM, SPEED_5KM, t);
    }
    if (kmVal <= 7){
      const t = smoothStep(clamp((kmVal-3)/4,0,1));
      return lerp(SPEED_5KM, SPEED_10KM, t);
    }
    if (kmVal <= 15){
      const t = smoothStep(clamp((kmVal-7)/8,0,1));
      return lerp(SPEED_10KM, SPEED_20KM, t);
    }
    if (kmVal <= 25){
      const t = smoothStep(clamp((kmVal-15)/10,0,1));
      return lerp(SPEED_20KM, SPEED_30KM, t);
    }
    const t = smoothStep(clamp((kmVal-25)/10,0,1));
    return lerp(SPEED_30KM, SPEED_40KM, t);
  }

  function reset() {
    state.started=false;
    state.over=false;
    state.t=0; state.dt=0; state.lastTs=0;

    state.speed=SPEED_0KM;
    state.spawnTimer=0.65;
    state.distancePx=0;
    state.kmCount=0;
    state.score=0;

    state.lives=START_LIVES;
    state.inv=0;
    state.holding=false;
    state.holdTime=0;

    state.shake=0;
    state.addedUpToKm=-1;

    obstacles.length=0;
    swimmers.length=0;
    bubbles.length=0;

    octo.x = Math.max(90, W()*0.26);
    octo.y = H()*0.52;
    octo.vy = 0;
    octo.blink = 0;
    octo.phase = 0;

    for (let i=0;i<10;i++) spawnFish(true);
  }

  function startIfNeeded(){ if (!state.started && !state.over) state.started = true; }

  function down() {
    if (state.over) return;
    startIfNeeded();
    state.holding = true;
    state.holdTime = 0;
    octo.vy = Math.min(octo.vy, 140);
    octo.vy += TAP_IMPULSE;
    for (let i=0;i<5;i++) spawnBubble(octo.x-10, octo.y+8, rand(2,4));
  }
  function up() { state.holding = false; state.holdTime = 0; }

  function restartTap(x,y){
    if (!state.over) return false;
    const bw=Math.min(270, W()*0.64), bh=54;
    const bx=(W()-bw)/2, by=H()*0.62;
    return x>=bx && x<=bx+bw && y>=by && y<=by+bh;
  }

  function getXY(ev){
    const rect = canvas.getBoundingClientRect();
    const p = (ev.touches && ev.touches[0]) ? ev.touches[0] : ev;
    return { x:(p.clientX ?? 0) - rect.left, y:(p.clientY ?? 0) - rect.top };
  }

  canvas.addEventListener("pointerdown", (ev)=>{
    const {x,y}=getXY(ev);

    // Restart button on game over
    if (restartTap(x,y)) { reset(); return; }

    // If we're on the start screen, only the Play bubble starts the run
    if (!state.started && !state.over){
      const dx = x - state.playBtn.x;
      const dy = y - state.playBtn.y;
      if (dx*dx + dy*dy <= state.playBtn.r*state.playBtn.r){
        down();
      }
      return;
    }

    // Normal gameplay
    down();
  }, { passive:true });

canvas.addEventListener("pointerup", up, { passive:true });
  canvas.addEventListener("pointercancel", up, { passive:true });
  canvas.addEventListener("touchstart", (e)=>{ e.preventDefault(); }, { passive:false });

  addEventListener("keydown", (e)=>{
    if (e.code==="Space" || e.code==="ArrowUp") { e.preventDefault(); if (state.over){ reset(); return; } down(); }
  });
  addEventListener("keyup", (e)=>{
    if (e.code==="Space" || e.code==="ArrowUp") { e.preventDefault(); up(); }
  });

  function spawnObstacle(){
    const w = rand(64, 86);
    const kmVal = km();
    const gapH = gapAt(kmVal, H());
    const margin = Math.max(86, H()*0.16);

    const minY = margin;
    const maxY = H() - margin - gapH;
    const gapY = rand(minY, maxY);

    const palette = [rand(330, 360), rand(0, 40), rand(150, 190), rand(40, 70)];
    const hue = palette[Math.floor(Math.random()*palette.length)];
    obstacles.push({
      x: W() + rand(90, 150),
      gapY, gapH, w,
      seed: Math.random()*10,
      hue,
      variant: Math.random()<0.5 ? "branch" : "fan"
    });
  }

  function spawnFish(initial=false){
    const y = rand(H()*0.16, H()*0.86);
    swimmers.push({
      x: initial ? rand(0,W()) : W() + rand(40, 240),
      y,
      s: rand(0.65, 1.2),
      hue: rand(0, 360),
      phase: Math.random()*10,
      speedK: rand(0.10, 0.26),
      kind: Math.random()<0.78 ? "fish" : "special"
    });
  }

  function spawnBubble(x,y,r){
    bubbles.push({ x:x+rand(-6,6), y:y+rand(-6,6), r, vx:rand(-12,12), vy:rand(-70,-130), life:0, maxLife:rand(1.0,1.8) });
    if (bubbles.length > 180) bubbles.splice(0, bubbles.length-180);
  }

  function applyKmDecor(kmInt){
    if (kmInt % 2 === 0) spawnFish(false);
    if (kmInt % 5 === 0) spawnFish(false);
  }

  function circleRect(cx,cy,cr, rx,ry,rw,rh){
    const nx = clamp(cx, rx, rx+rw);
    const ny = clamp(cy, ry, ry+rh);
    const dx = cx-nx, dy=cy-ny;
    return dx*dx + dy*dy <= cr*cr;
  }

  function takeHit(){
    if (state.inv>0) return;
    state.lives -= 1;
    state.inv = HIT_INVINCIBLE;
    state.shake = 10;
    for (let i=0;i<12;i++) spawnBubble(octo.x, octo.y, rand(2,5));
    if (state.lives<=0){
      state.over = true;
      if (state.score > state.best){
        state.best = state.score;
        localStorage.setItem("octoFlapBest3", String(state.best));
      }
    }
  }

  function drawBackground(){
    const w=W(), h=H();
    const g = ctx.createLinearGradient(0,0,0,h);
    g.addColorStop(0, "#6ff7ff");
    g.addColorStop(0.25, "#52c8ff");
    g.addColorStop(0.55, "#2b7cff");
    g.addColorStop(1, "#0b1b42");
    ctx.fillStyle = g;
    ctx.fillRect(0,0,w,h);

    ctx.globalAlpha = 0.22;
    for (let i=0;i<5;i++){
      const yy = h*(0.18 + i*0.12) + Math.sin(state.t*0.6 + i)*14;
      const gg = ctx.createLinearGradient(0, yy, w, yy);
      gg.addColorStop(0, "rgba(255,255,255,0)");
      gg.addColorStop(0.5, "rgba(255,255,255,1)");
      gg.addColorStop(1, "rgba(255,255,255,0)");
      ctx.fillStyle = gg;
      ctx.beginPath();
      ctx.ellipse(w/2 + Math.sin(state.t*0.35+i)*90, yy, w*0.62, 26, 0, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;

    ctx.globalAlpha = 0.10;
    ctx.fillStyle = "rgba(255,255,255,0.9)";
    for (let i=0;i<6;i++){
      const yy = h*(0.12 + i*0.10) + Math.sin(state.t*0.95 + i*0.7)*10;
      ctx.beginPath();
      ctx.ellipse(w/2 + Math.sin(state.t*0.45+i)*90, yy, w*0.58, 18+Math.sin(state.t*1.2+i)*8, 0.08, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;

    layers.forEach((L, idx) => {
      L.x -= state.speed * L.speed * state.dt;
      if (L.x < -w) L.x += w;

      ctx.globalAlpha = L.alpha;
      ctx.fillStyle = idx===0 ? "#0d3a66" : idx===1 ? "#0a2f57" : "#072449";
      const baseY = h*0.96;
      for (let rep=-1; rep<=1; rep++) {
        const ox = L.x + rep*w;
        ctx.beginPath();
        ctx.moveTo(ox, h);
        for (let x=0; x<=w; x+=56) {
          const yy = baseY - (120 + idx*60) + Math.sin((x*0.010) + state.t*0.55 + idx)*L.amp;
          ctx.quadraticCurveTo(ox+x+28, yy-20, ox+x+56, yy);
        }
        ctx.lineTo(ox + w, h);
        ctx.closePath();
        ctx.fill();
      }
      ctx.globalAlpha = 1;
    });

    if (Math.random() < 0.07) spawnBubble(rand(0,w), rand(h*0.30, h*0.92), rand(1.6,3.0));
  }

  function drawCoralPillar(x, y, w, h, hue, seed, flip=false, variant="branch"){
    // Coral more organic + stable (no time-based tremble)
    const sway = (Math.sin(seed*2.3) + Math.sin(seed*5.1)) * 2.0;

    ctx.save();
    if (flip){
      ctx.translate(0, y);
      ctx.scale(1, -1);
      y = 0;
    }

    // Soft drop shadow that follows the shape (no black rectangle)
    ctx.shadowColor = "rgba(0,0,0,0.18)";
    ctx.shadowBlur = 18;
    ctx.shadowOffsetX = 8;
    ctx.shadowOffsetY = 2;

    const grad = ctx.createLinearGradient(x, y, x+w, y+h);
    grad.addColorStop(0, `hsla(${hue}, 92%, 64%, 0.99)`);
    grad.addColorStop(1, `hsla(${(hue+28)%360}, 92%, 50%, 0.99)`);
    ctx.fillStyle = grad;

    // Main coral body
    const leftIn  = w*(0.10 + 0.02*Math.sin(seed*3.7));
    const rightIn = w*(0.10 + 0.02*Math.cos(seed*4.1));
    ctx.beginPath();
    ctx.moveTo(x+leftIn, y+h);
    ctx.lineTo(x+leftIn, y + h*0.26);
    ctx.bezierCurveTo(
      x + w*(0.10) + sway, y + h*0.06,
      x + w*(0.55) + sway*0.4, y + h*0.04,
      x + w - rightIn, y + h*0.24
    );
    ctx.lineTo(x + w - rightIn, y + h);
    ctx.closePath();
    ctx.fill();

    // Reset shadow for details
    ctx.shadowColor = "rgba(0,0,0,0)";
    ctx.shadowBlur = 0;
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 0;

    // Arms / polyps
    ctx.globalAlpha = 0.92;
    ctx.fillStyle = `hsla(${(hue+12)%360}, 92%, 72%, 0.92)`;
    const arms = variant==="fan" ? 6 : 4;
    for (let i=0;i<arms;i++){
      const ax = x + w*(0.18 + i*(0.64/(arms-1))) + Math.sin(seed+i)*2.2;
      const ay = y + h*(variant==="fan" ? 0.28 : 0.40) + i*3;
      const aw = w*(0.12 + 0.05*Math.sin(seed*1.7+i));
      const ah = h*(0.09 + 0.05*Math.cos(seed*2.1+i));
      ctx.beginPath();
      ctx.ellipse(ax, ay, aw, ah, (i%2?0.6:-0.6), 0, Math.PI*2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;

    // Inner texture dots (static)
    ctx.globalAlpha = 0.25;
    ctx.fillStyle = "rgba(255,255,255,0.9)";
    for (let i=0;i<10;i++){
      const dx = x + w*(0.18 + 0.70*Math.abs(Math.sin(seed*1.3+i)));
      const dy = y + h*(0.22 + 0.72*Math.abs(Math.cos(seed*1.1+i)));
      ctx.beginPath();
      ctx.arc(dx, dy, 2.0, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;

    // Outline (clean)
    ctx.strokeStyle = "rgba(0,0,0,0.18)";
    ctx.lineWidth = 2;
    ctx.stroke();

    // Highlight strip (static)
    ctx.globalAlpha = 0.18;
    ctx.fillStyle = "rgba(255,255,255,0.95)";
    ctx.beginPath();
    ctx.roundRect(x+w*0.18, y+h*0.30, w*0.10, h*0.42, 10);
    ctx.fill();
    ctx.globalAlpha = 1;

    ctx.restore();
  }

  function drawObstacle(o){
    const topH = o.gapY;
    const botY = o.gapY + o.gapH;
    const botH = H() - botY;

    // Organic corals only (no rectangular shadow)
    if (topH > 10) drawCoralPillar(o.x, topH, o.w, topH, o.hue, o.seed, true, o.variant);
    if (botH > 10) drawCoralPillar(o.x, botY, o.w, botH, o.hue, o.seed+1.7, false, o.variant);
  }

  function drawSwimmer(s){
    const bob = Math.sin(state.t*1.2 + s.phase) * 6;
    const x = s.x, y = s.y + bob;
    const scale = s.s;

    ctx.save();
    ctx.translate(x, y);
    ctx.scale(scale, scale);

    if (s.kind === "fish"){
      const body = `hsla(${s.hue}, 92%, 62%, 0.95)`;
      const fin  = `hsla(${(s.hue+40)%360}, 92%, 55%, 0.95)`;
      ctx.fillStyle = body;
      ctx.beginPath(); ctx.ellipse(0,0,18,10,0,0,Math.PI*2); ctx.fill();
      ctx.fillStyle = fin;
      ctx.beginPath(); ctx.moveTo(-16,0); ctx.lineTo(-30,-10); ctx.lineTo(-30,10); ctx.closePath(); ctx.fill();
      ctx.fillStyle = "#0a1c2d";
      ctx.beginPath(); ctx.arc(8,-2,2.3,0,Math.PI*2); ctx.fill();
      ctx.fillStyle = "rgba(255,255,255,0.65)";
      ctx.beginPath(); ctx.arc(9,-3,1.0,0,Math.PI*2); ctx.fill();
    } else {
      ctx.fillStyle = `hsla(${s.hue}, 88%, 64%, 0.95)`;
      ctx.beginPath(); ctx.ellipse(0,0,18,14,0,0,Math.PI*2); ctx.fill();
      ctx.strokeStyle = "rgba(255,255,255,0.40)";
      ctx.lineWidth = 2;
      for (let i=0;i<7;i++){
        const a = i*(Math.PI*2/7);
        ctx.beginPath();
        ctx.moveTo(Math.cos(a)*6, Math.sin(a)*5);
        ctx.lineTo(Math.cos(a)*22, Math.sin(a)*16);
        ctx.stroke();
      }
      ctx.fillStyle = "#081629";
      ctx.beginPath(); ctx.arc(6,-2,2.3,0,Math.PI*2); ctx.fill();
    }

    ctx.restore();
  }

  function drawOcto(){
    octo.phase += state.dt * (state.holding ? 7.5 : 5.5);

    const vy = octo.vy;
    const stretch = clamp((-vy)/900, -0.22, 0.30);
    const squash  = clamp((vy)/1000, 0, 0.22);
    const sx = 1 + squash - stretch*0.25;
    const sy = 1 - squash + stretch;

    const t = state.t;
    const invFlash = (state.inv>0) ? (Math.sin(t*24)>0 ? 0.35 : 1.0) : 1.0;
    const hue = 185 + Math.sin(t*0.6)*18 + clamp(km()*2.2, 0, 90);

    ctx.globalAlpha = 0.10 * invFlash;
    ctx.fillStyle = "#000";
    ctx.beginPath();
    ctx.ellipse(octo.x, octo.y + 38, 22, 10, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;

    ctx.save();
    ctx.translate(octo.x, octo.y);
    ctx.scale(sx, sy);
    ctx.globalAlpha = invFlash;

    ctx.fillStyle = `hsl(${hue}, 86%, 60%)`;
    ctx.beginPath(); ctx.ellipse(0, 0, 22, 18, 0, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(0, -16, 18, 16, 0, 0, Math.PI*2); ctx.fill();

    ctx.strokeStyle = `hsla(${hue}, 86%, 56%, 0.95)`;
    ctx.lineWidth = 7;
    ctx.lineCap = "round";
    for (let i=0;i<5;i++){
      const a = -1.1 + i*0.55;
      const sway = Math.sin(octo.phase + i*1.1) * 6;
      const x0 = Math.cos(a)*8;
      const y0 = 10;
      const x1 = x0 + sway;
      const y1 = 30 + i*1.5;
      ctx.beginPath();
      ctx.moveTo(x0,y0);
      ctx.quadraticCurveTo(x1*0.6, y1*0.65, x1, y1);
      ctx.stroke();
    }

    octo.blink -= state.dt;
    if (octo.blink<=0 && Math.random()<0.012) octo.blink = 0.11;

    if (octo.blink>0){
      ctx.strokeStyle = "#062033";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(-10,-18); ctx.lineTo(-4,-18);
      ctx.moveTo(4,-18);  ctx.lineTo(10,-18);
      ctx.stroke();
    } else {
      ctx.fillStyle = "#062033";
      ctx.beginPath();
      ctx.arc(-7,-18,3.2,0,Math.PI*2);
      ctx.arc(7,-18,3.2,0,Math.PI*2);
      ctx.fill();
      ctx.fillStyle = "rgba(255,255,255,0.7)";
      ctx.beginPath();
      ctx.arc(-6,-19,1.1,0,Math.PI*2);
      ctx.arc(8,-19,1.1,0,Math.PI*2);
      ctx.fill();
    }

    ctx.strokeStyle = "rgba(6,32,51,0.9)";
    ctx.lineWidth = 3;
    ctx.lineCap="round";
    ctx.beginPath();
    ctx.arc(0,-8,8,0.15*Math.PI,0.85*Math.PI);
    ctx.stroke();

    ctx.globalAlpha = 1;
    ctx.restore();
  }

  function drawBubbles(){
    ctx.globalAlpha = 0.70;
    ctx.fillStyle = "rgba(255,255,255,0.85)";
    for (const b of bubbles){
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 0.14;
      ctx.beginPath();
      ctx.arc(b.x - b.r*0.3, b.y - b.r*0.3, b.r*0.35, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 0.70;
    }
    ctx.globalAlpha = 1;
  }

  function drawHUD(){
    const pad=14;
    const w=W(), h=H();

    const fontRound = '"Arial Rounded MT Bold","Nunito","Trebuchet MS",system-ui,-apple-system,"Segoe UI",Roboto';

    // --- HUD panefunction drawHUD(){
    const pad=14;
    const w=W(), h=H();

    // More rounded for main titles
    const fontUI   = '"Arial Rounded MT Bold","Nunito","Trebuchet MS",system-ui,-apple-system,"Segoe UI",Roboto';
    const fontLogo = '"Arial Rounded MT Bold","Comic Sans MS","Trebuchet MS",system-ui,-apple-system,"Segoe UI",Roboto';

    // --- HUD panel (top-left) ---
    ctx.fillStyle="rgba(0,0,0,0.22)";
    ctx.beginPath();
    ctx.roundRect(pad, pad, 260, 78, 18);
    ctx.fill();

    // accent strip
    ctx.fillStyle="rgba(111,247,255,0.35)";
    ctx.beginPath();
    ctx.roundRect(pad+10, pad+12, 6, 54, 10);
    ctx.fill();

    // Label + value (POINTS)
    ctx.fillStyle="rgba(111,247,255,0.95)";
    ctx.font=`900 16px ${fontUI}`;
    ctx.fillText("POINTS", pad+26, pad+30);

    ctx.fillStyle="rgba(255,255,255,0.96)";
    ctx.font=`950 28px ${fontUI}`;
    ctx.fillText(String(state.score), pad+26, pad+58);

    // Hearts only (colored)
    ctx.font=`950 18px ${fontUI}`;
    ctx.fillStyle="rgba(255,90,140,0.95)";
    const hearts = "❤".repeat(Math.max(0, Math.min(12, state.lives)));
    ctx.fillText(hearts + (state.lives>12 ? " +" : ""), pad+26, pad+78);

    // Best + distance (top-right) — keep minimal
    ctx.textAlign="right";
    ctx.fillStyle="rgba(255,255,255,0.75)";
    ctx.font=`900 14px ${fontUI}`;
    ctx.fillText(`BEST ${state.best}`, w-pad, pad+22);
    ctx.fillStyle="rgba(255,255,255,0.60)";
    ctx.font=`800 12px ${fontUI}`;
    ctx.fillText(`${km().toFixed(2)} km`, w-pad, pad+40);
    ctx.textAlign="left";

    // --- Curved logo renderer (letters on arc) ---
    function drawCurvedLogo(text, cx, cy, radius, scale){
      ctx.save();
      ctx.translate(cx, cy);
      ctx.scale(scale, scale);

      const fontSize = 96;
      ctx.font = `950 ${fontSize}px ${fontLogo}`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";

      // measure total width approx by summing glyph widths
      var widths = [];
      for (var i=0;i<text.length;i++){ widths.push(ctx.measureText(text.charAt(i)).width); }
      var total = 0;
      for (var j=0;j<widths.length;j++){ total += widths[j]; }
      // map width to angle span
      const angSpan = clamp(total / 650, 0.95, 1.35); // radians span
      const startAng = -angSpan/2;

      // helper to draw one pass (shadow/outline/fill)
      function drawPass(dx, dy, strokeW, strokeStyle, fillStyle, alpha, doFill){
        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.lineWidth = strokeW;
        ctx.strokeStyle = strokeStyle;
        ctx.fillStyle = fillStyle;

        let acc = 0;
        for (let i=0;i<text.length;i++){
          const ch = text[i];
          const wch = widths[i];
          const mid = acc + wch/2;
          const t = (mid / total);
          const ang = startAng + t*angSpan;
          const x = Math.sin(ang) * radius + dx;
          const y = -Math.cos(ang) * radius + dy;

          ctx.save();
          ctx.translate(x, y);
          ctx.rotate(ang);
          if (!doFill) ctx.strokeText(ch, 0, 0);
          else ctx.fillText(ch, 0, 0);
          ctx.restore();
          acc += wch;
        }
        ctx.restore();
      }

      // Shadow slab behind
      drawPass(10, 18, 22, "rgba(0,0,0,0.55)", "#000", 0.26, false);

      // Dark outline
      drawPass(0, 0, 22, "rgba(0,0,0,0.55)", "#000", 1.0, false);

      // White rim
      drawPass(0, 0, 15, "rgba(255,255,255,0.97)", "#fff", 1.0, false);

      // Gradient fill
      const g = ctx.createLinearGradient(-260, -80, 260, 80);
      g.addColorStop(0.00, "#28d6ff");
      g.addColorStop(0.30, "#7dff6a");
      g.addColorStop(0.55, "#ffe85a");
      g.addColorStop(0.78, "#ff6aa2");
      g.addColorStop(1.00, "#9b6bff");

      // Fill letters
      (function(){
        ctx.save();
        ctx.fillStyle = g;
        ctx.globalAlpha = 1;
        let acc = 0;
        for (let i=0;i<text.length;i++){
          const ch = text[i];
          const wch = widths[i];
          const mid = acc + wch/2;
          const t = (mid / total);
          const ang = startAng + t*angSpan;
          const x = Math.sin(ang) * radius;
          const y = -Math.cos(ang) * radius;

          ctx.save();
          ctx.translate(x, y);
          ctx.rotate(ang);
          ctx.fillText(ch, 0, 0);
          ctx.restore();
          acc += wch;
        }
        ctx.restore();
      })();

      // Shine
      ctx.globalAlpha = 0.18;
      ctx.fillStyle = "#fff";
      ctx.beginPath();
      ctx.ellipse(0, -radius-22, 240, 18, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 1;

      ctx.restore();
    }

    // Rounded play triangle helper
    function drawRoundedPlayTriangle(cx, cy, size){
      const s = size;
      const r = s*0.22; // corner radius
      // Define points for a right-pointing triangle
      const p1 = {x: cx - s*0.22, y: cy - s*0.32};
      const p2 = {x: cx - s*0.22, y: cy + s*0.32};
      const p3 = {x: cx + s*0.38, y: cy};

      // Rounded path using quadratic curves at corners
      ctx.beginPath();
      // move near p1->p3 edge
      ctx.moveTo(p1.x + r, p1.y + r*0.2);
      // corner near p1
      ctx.quadraticCurveTo(p1.x, p1.y, p1.x + r*0.6, p1.y + r);
      // edge to p3
      ctx.quadraticCurveTo((p1.x+p3.x)/2, (p1.y+p3.y)/2, p3.x - r, p3.y - r*0.2);
      // corner near p3
      ctx.quadraticCurveTo(p3.x, p3.y, p3.x - r, p3.y + r*0.2);
      // edge to p2
      ctx.quadraticCurveTo((p3.x+p2.x)/2, (p3.y+p2.y)/2, p2.x + r*0.6, p2.y - r);
      // corner near p2
      ctx.quadraticCurveTo(p2.x, p2.y, p2.x + r, p2.y - r*0.2);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
    }

    // --- Play bubble button (start screen) ---
    function drawPlayBubble(cx, cy, r){
      // store for hit-test
      state.playBtn.x = cx;
      state.playBtn.y = cy;
      state.playBtn.r = r;

      // Warm glow
      ctx.globalAlpha = 0.18;
      const glow = ctx.createRadialGradient(cx, cy, r*0.3, cx, cy, r*1.4);
      glow.addColorStop(0, "rgba(255,235,160,0.55)");
      glow.addColorStop(0.6, "rgba(120,255,210,0.28)");
      glow.addColorStop(1, "rgba(0,0,0,0)");
      ctx.fillStyle = glow;
      ctx.beginPath();
      ctx.arc(cx, cy, r*1.35, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 1;

      // Bubble fill
      const g = ctx.createRadialGradient(cx-r*0.28, cy-r*0.35, r*0.2, cx, cy, r);
      g.addColorStop(0, "rgba(255,255,255,0.88)");
      g.addColorStop(0.35, "rgba(170,250,255,0.58)");
      g.addColorStop(1, "rgba(60,170,255,0.38)");
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.arc(cx, cy, r, 0, Math.PI*2);
      ctx.fill();

      // Rim
      ctx.strokeStyle = "rgba(255,255,255,0.78)";
      ctx.lineWidth = 4;
      ctx.stroke();

      // Highlight
      ctx.globalAlpha = 0.48;
      ctx.fillStyle = "rgba(255,255,255,0.95)";
      ctx.beginPath();
      ctx.ellipse(cx - r*0.25, cy - r*0.25, r*0.30, r*0.18, -0.4, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 1;

      // Play icon (warm + rounded)
      const pg = ctx.createLinearGradient(cx-r*0.2, cy-r*0.4, cx+r*0.5, cy+r*0.4);
      pg.addColorStop(0, "#7dff6a");
      pg.addColorStop(0.55, "#ffe85a");
      pg.addColorStop(1, "#ff6aa2");
      ctx.fillStyle = pg;
      ctx.strokeStyle = "rgba(0,0,0,0.18)";
      ctx.lineWidth = 3;
      drawRoundedPlayTriangle(cx, cy, r*0.95);
    }

    // --- Start screen ---
    if (!state.started && !state.over){
      ctx.save();
      ctx.globalAlpha = 0.30;
      ctx.fillStyle = "#000";
      ctx.fillRect(0,0,w,h);
      ctx.globalAlpha = 1;

      // soft beams
      ctx.globalAlpha = 0.16;
      ctx.fillStyle = "#fff";
      for (let i=0;i<3;i++){
        ctx.beginPath();
        ctx.ellipse(w*(0.25+i*0.25), h*0.22, w*0.22, h*0.55, 0.2, 0, Math.PI*2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;

      // Big curved logo taking more space
      const logoScale = Math.min(1.10, Math.max(0.86, w/880));
      drawCurvedLogo("POLYDASH", w/2, h*0.36, 120, logoScale);

      // Play bubble below
      const r = Math.max(38, Math.min(60, w*0.07));
      drawPlayBubble(w/2, h*0.36 + 140, r);

      ctx.restore();
    } else {
      state.playBtn.r = 0;
    }

    // --- Game over ---
    if (state.over){
      ctx.save();
      ctx.fillStyle="rgba(0,0,0,0.45)";
      ctx.fillRect(0,0,w,h);

      // Bigger, rounded title
      ctx.textAlign="center";
      ctx.textBaseline="middle";
      ctx.font=`950 68px ${fontLogo}`;

      // shadow + outlines
      ctx.lineWidth = 20;
      ctx.strokeStyle = "rgba(0,0,0,0.55)";
      ctx.strokeText("GAME OVER", w/2, h*0.32 + 16);
      ctx.lineWidth = 14;
      ctx.strokeStyle = "rgba(255,255,255,0.97)";
      ctx.strokeText("GAME OVER", w/2, h*0.32);

      const gg = ctx.createLinearGradient(w*0.25, h*0.30, w*0.75, h*0.38);
      gg.addColorStop(0, "#28d6ff");
      gg.addColorStop(0.35, "#7dff6a");
      gg.addColorStop(0.7, "#ffe85a");
      gg.addColorStop(1, "#ff6aa2");
      ctx.fillStyle = gg;
      ctx.fillText("GAME OVER", w/2, h*0.32);

      // POINTS large under GAME OVER
      ctx.font=`900 26px ${fontUI}`;
      ctx.fillStyle="rgba(111,247,255,0.95)";
      ctx.fillText("POINTS", w/2, h*0.42);
      ctx.font=`950 44px ${fontUI}`;
      ctx.fillStyle="rgba(255,255,255,0.96)";
      ctx.fillText(String(state.score), w/2, h*0.48);

      // BEST below points (not side-by-side)
      ctx.font=`900 20px ${fontUI}`;
      ctx.fillStyle="rgba(255,255,255,0.85)";
      ctx.fillText(`BEST ${state.best}`, w/2, h*0.54);

      // button
      const bw=Math.min(320, w*0.74), bh=64;
      const bx=(w-bw)/2, by=h*0.66;

      ctx.globalAlpha = 0.22;
      ctx.fillStyle = "#80ffd2";
      ctx.beginPath();
      ctx.roundRect(bx-10, by-10, bw+20, bh+20, 24);
      ctx.fill();
      ctx.globalAlpha = 1;

      ctx.fillStyle="rgba(80,255,210,0.95)";
      ctx.beginPath(); ctx.roundRect(bx,by,bw,bh,22); ctx.fill();

      ctx.fillStyle="rgba(2,16,36,0.95)";
      ctx.font=`950 24px ${fontUI}`;
      ctx.fillText("RESTART", w/2, by+bh/2+1);

      ctx.textAlign="left";
      ctx.textBaseline="alphabetic";
      ctx.restore();
    }
  }o(x+r,y);
      this.arcTo(x+w,y,x+w,y+h,r);
      this.arcTo(x+w,y+h,x,y+h,r);
      this.arcTo(x,y+h,x,y,r);
      this.arcTo(x,y,x+w,y,r);
      this.closePath();
      return this;
    };
  }

  function step(ts){
    if (!state.lastTs) state.lastTs = ts;
    state.dt = Math.min(0.033, (ts - state.lastTs)/1000);
    state.lastTs = ts;
    state.t += state.dt;

    if (state.inv>0) state.inv = Math.max(0, state.inv - state.dt);

    const kmVal = km();
    const targetSpeed = speedAt(kmVal);
    state.speed += (targetSpeed - state.speed) * (1 - Math.pow(0.001, state.dt));

    const spawnInterval = spawnIntervalAt(kmVal);

    if (state.started && !state.over){
      state.distancePx += state.speed * state.dt;

      const kmNow = Math.floor(state.distancePx / KM_PX);
      if (kmNow > state.kmCount){
        const delta = kmNow - state.kmCount;
        state.kmCount = kmNow;
        state.score += delta * POINTS_PER_KM;

        for (let k=state.addedUpToKm+1; k<=kmNow; k++){
          applyKmDecor(k);
          state.addedUpToKm = k;
        }

        if (kmNow >= BONUS_START_KM && kmNow % BONUS_EVERY_KM === 0){
          // Note: JS uses && and ===; fixed below in runtime check
        }
      }

      // correct JS conditional for bonus heart
      if (kmNow >= BONUS_START_KM && kmNow % BONUS_EVERY_KM === 0){
        // ensure we only grant once per milestone:
        // grant exactly when crossing the milestone (handled by kmNow>kmCount above),
        // but keep guard anyway:
        if (kmNow !== 0){
          state.lives += 1;
          for (let i=0;i<16;i++) spawnBubble(octo.x, octo.y, rand(2,5));
        }
      }

      state.spawnTimer -= state.dt;
      const okWarmup = state.t > SAFE_START_TIME;

      const last = obstacles[obstacles.length-1];
      const minGapX = Math.max(300, state.speed * 0.95);
      const okGap = !last || (W() + 140) - last.x >= minGapX;

      if (okWarmup && state.spawnTimer <= 0 && okGap){
        spawnObstacle();
        state.spawnTimer = spawnInterval + rand(-0.10, 0.22);
      }

      let ay = GRAVITY;
      if (state.holding){
        state.holdTime += state.dt;
        if (state.holdTime <= HOLD_MAX_TIME){
          const k = clamp(0.85 + state.holdTime*1.2, 0.85, 1.20);
          ay = GRAVITY - HOLD_THRUST*k;
          if (Math.random()<0.18) spawnBubble(octo.x-12, octo.y+10, rand(2,4));
        } else {
          ay = GRAVITY;
        }
      } else {
        state.holdTime = 0;
      }

      octo.vy += ay * state.dt;
      octo.vy = clamp(octo.vy, VY_UP_CAP, VY_DOWN_CAP);
      octo.y += octo.vy * state.dt;

      const margin = 38;
      if (octo.y < margin){
        octo.y = margin;
        octo.vy = 140;
        takeHit();
      }
      if (octo.y > H()-margin){
        octo.y = H()-margin;
        octo.vy = -200;
        takeHit();
      }

      for (let i=obstacles.length-1; i>=0; i--){
        const o = obstacles[i];
        o.x -= state.speed * state.dt;
        if (o.x + o.w < -160) obstacles.splice(i,1);
      }

      for (let i=swimmers.length-1; i>=0; i--){
        const s = swimmers[i];
        s.x -= state.speed * s.speedK * state.dt;
        if (s.x < -260) swimmers.splice(i,1);
      }
      if (swimmers.filter(s=>s.kind==="fish").length < 10) spawnFish(false);

      for (let i=bubbles.length-1; i>=0; i--){
        const b = bubbles[i];
        b.life += state.dt;
        b.x += b.vx * state.dt;
        b.y += b.vy * state.dt;
        b.vx += Math.sin(state.t*2 + i)*3 * state.dt;
        if (b.life > b.maxLife || b.y < -50) bubbles.splice(i,1);
      }

      const cr = 18;
      const cx = octo.x, cy = octo.y;

      for (const o of obstacles){
        const ox = o.x, ow = o.w;
        const topRect = {x: ox+8, y: 0, w: ow-16, h: o.gapY-6};
        const botRect = {x: ox+8, y: o.gapY + o.gapH + 6, w: ow-16, h: H() - (o.gapY + o.gapH) - 6};

        if (circleRect(cx,cy,cr, topRect.x, topRect.y, topRect.w, topRect.h) ||
            circleRect(cx,cy,cr, botRect.x, botRect.y, botRect.w, botRect.h)){
          takeHit();
          break;
        }
      }
    } else {
      octo.y = lerp(octo.y, H()*0.52, 1 - Math.pow(0.001, state.dt));
      octo.vy = 0;
    }

    let shx=0, shy=0;
    if (state.shake>0){
      state.shake = Math.max(0, state.shake - state.dt*20);
      const s = state.shake;
      shx = (Math.random()*2-1)*s;
      shy = (Math.random()*2-1)*s;
    }

    ctx.save();
    ctx.translate(shx, shy);
    drawBackground();
    for (const s of swimmers) drawSwimmer(s);
    for (const o of obstacles) drawObstacle(o);
    drawOcto();
    drawBubbles();
    drawHUD();
    ctx.restore();

    requestAnimationFrame(step);
  }

  reset();
  requestAnimationFrame(step);
})();
</script>
</body>
</html>
